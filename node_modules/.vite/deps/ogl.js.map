{"version":3,"file":"ogl.js","names":["length","copy","set","add","subtract","multiply","divide","scale","distance","squaredDistance","squaredLength","negate","inverse","normalize","dot","cross","smoothLerp","transformMat4","transformMat3","exactEquals","Vec3Func.length","Vec3Func.distance","Vec3Func.squaredLength","Vec3Func.squaredDistance","Vec3Func.dot","Vec3Func.exactEquals","Vec3Func.angle","tempVec3","ID","scale","ID","vertex","fragment","length","tempVec3","ID","id","copy","set","add","scale","length","normalize","dot","lerp","identity","multiply","invert","dot","copy","vec4.copy","set","vec4.set","add","vec4.add","scale","vec4.scale","vec4.dot","lerp","vec4.lerp","length","vec4.length","normalize","vec4.normalize","QuatFunc.dot","copy","set","identity","invert","multiply","translate","scale","rotate","vec3.length","fromQuat","add","subtract","scale","Mat4Func.getMaxScaleOnAxis","Mat4Func.determinant","invert","tempMat4","tempVec3a","tempVec3b","normal","copy","set","identity","multiply","scale","ID","length","ColorFunc.parseColor","lerp","Vec2Func.length","Vec2Func.distance","Vec2Func.squaredDistance","Vec2Func.squaredLength","Vec2Func.cross","Vec2Func.dot","Vec2Func.exactEquals","Vec4Func.dot","normal","uv","normal","uv","normal","uv","normal","uv","vertex","normal","tempVec3","tempVec2a","tempVec2b","distance","angle","tempMat4","distance","a","b","normal","point","angle","tempVec3","tempVec3","tempVec3","tempMat4","normal","angle","vertex","defaultVertex","defaultFragment","tempMat4","scale","line","vertex","fragment","vertex","fragment","defaultVertex","defaultFragment","defaultVertex","defaultFragment","uv","vertex","fragment","id","size","texture","extras","data","scale","id","id","vertex","fragment","vertex","fragment","vertex","fragment","vertex","fragment"],"sources":["../../ogl/src/math/functions/Vec3Func.js","../../ogl/src/math/Vec3.js","../../ogl/src/core/Geometry.js","../../ogl/src/core/Program.js","../../ogl/src/core/Renderer.js","../../ogl/src/math/functions/Vec4Func.js","../../ogl/src/math/functions/QuatFunc.js","../../ogl/src/math/Quat.js","../../ogl/src/math/functions/Mat4Func.js","../../ogl/src/math/Mat4.js","../../ogl/src/math/functions/EulerFunc.js","../../ogl/src/math/Euler.js","../../ogl/src/core/Transform.js","../../ogl/src/core/Camera.js","../../ogl/src/math/functions/Mat3Func.js","../../ogl/src/math/Mat3.js","../../ogl/src/core/Mesh.js","../../ogl/src/core/Texture.js","../../ogl/src/core/RenderTarget.js","../../ogl/src/math/functions/ColorFunc.js","../../ogl/src/math/Color.js","../../ogl/src/math/functions/Vec2Func.js","../../ogl/src/math/Vec2.js","../../ogl/src/math/Vec4.js","../../ogl/src/extras/Plane.js","../../ogl/src/extras/Box.js","../../ogl/src/extras/Sphere.js","../../ogl/src/extras/Cylinder.js","../../ogl/src/extras/Triangle.js","../../ogl/src/extras/Torus.js","../../ogl/src/extras/Orbit.js","../../ogl/src/extras/Raycast.js","../../ogl/src/extras/Curve.js","../../ogl/src/extras/path/BaseSegment.js","../../ogl/src/extras/path/utils.js","../../ogl/src/extras/path/CubicBezierSegment.js","../../ogl/src/extras/path/QuadraticBezierSegment.js","../../ogl/src/extras/path/LineSegment.js","../../ogl/src/extras/path/Path.js","../../ogl/src/extras/Tube.js","../../ogl/src/extras/Post.js","../../ogl/src/extras/Animation.js","../../ogl/src/extras/Skin.js","../../ogl/src/extras/Text.js","../../ogl/src/extras/NormalProgram.js","../../ogl/src/extras/Flowmap.js","../../ogl/src/extras/GPGPU.js","../../ogl/src/extras/Polyline.js","../../ogl/src/extras/Shadow.js","../../ogl/src/extras/KTXTexture.js","../../ogl/src/extras/TextureLoader.js","../../ogl/src/extras/GLTFAnimation.js","../../ogl/src/extras/GLTFSkin.js","../../ogl/src/extras/InstancedMesh.js","../../ogl/src/extras/GLTFLoader.js","../../ogl/src/extras/DracoManager.js","../../ogl/src/extras/BasisManager.js","../../ogl/src/extras/WireMesh.js","../../ogl/src/extras/helpers/AxesHelper.js","../../ogl/src/extras/helpers/GridHelper.js","../../ogl/src/extras/helpers/VertexNormalsHelper.js","../../ogl/src/extras/helpers/FaceNormalsHelper.js","../../ogl/src/extras/Texture3D.js"],"sourcesContent":["const EPSILON = 0.000001;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    out[2] = 1.0 / a[2];\n    return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let len = x * x + y * y + z * z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n}\n\n/**\n * Performs a frame rate independant, linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec3} out\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    out[2] = b[2] + (az - b[2]) * exp;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n}\n\n/**\n * Same as above but doesn't apply translation.\n * Useful for rays.\n */\nexport function scaleRotateMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let qx = q[0],\n        qy = q[1],\n        qz = q[2],\n        qw = q[3];\n\n    let uvx = qy * z - qz * y;\n    let uvy = qz * x - qx * z;\n    let uvz = qx * y - qy * x;\n\n    let uuvx = qy * uvz - qz * uvy;\n    let uuvy = qz * uvx - qx * uvz;\n    let uuvz = qx * uvy - qy * uvx;\n\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport const angle = (function () {\n    const tempA = [0, 0, 0];\n    const tempB = [0, 0, 0];\n\n    return function (a, b) {\n        copy(tempA, a);\n        copy(tempB, b);\n\n        normalize(tempA, tempA);\n        normalize(tempB, tempB);\n\n        let cosine = dot(tempA, tempB);\n\n        if (cosine > 1.0) {\n            return 0;\n        } else if (cosine < -1.0) {\n            return Math.PI;\n        } else {\n            return Math.acos(cosine);\n        }\n    };\n})();\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n","import * as Vec3Func from './functions/Vec3Func.js';\n\nexport class Vec3 extends Array {\n    constructor(x = 0, y = x, z = x) {\n        super(x, y, z);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        Vec3Func.set(this, x, y, z);\n        return this;\n    }\n\n    copy(v) {\n        Vec3Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec3Func.add(this, va, vb);\n        else Vec3Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec3Func.subtract(this, va, vb);\n        else Vec3Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec3Func.multiply(this, this, v);\n        else Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec3Func.divide(this, this, v);\n        else Vec3Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec3Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec3Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec3Func.distance(this, v);\n        else return Vec3Func.length(this);\n    }\n\n    squaredLen() {\n        return Vec3Func.squaredLength(this);\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec3Func.squaredDistance(this, v);\n        else return Vec3Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec3Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) Vec3Func.cross(this, va, vb);\n        else Vec3Func.cross(this, this, va);\n        return this;\n    }\n\n    scale(v) {\n        Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec3Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec3Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec3Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec3Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec3Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    scaleRotateMatrix4(mat4) {\n        Vec3Func.scaleRotateMat4(this, this, mat4);\n        return this;\n    }\n\n    applyQuaternion(q) {\n        Vec3Func.transformQuat(this, this, q);\n        return this;\n    }\n\n    angle(v) {\n        return Vec3Func.angle(this, v);\n    }\n\n    lerp(v, t) {\n        Vec3Func.lerp(this, this, v, t);\n        return this;\n    }\n\n    smoothLerp(v, decay, dt) {\n        Vec3Func.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n\n    clone() {\n        return new Vec3(this[0], this[1], this[2]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n\n    transformDirection(mat4) {\n        const x = this[0];\n        const y = this[1];\n        const z = this[2];\n\n        this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n        this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n        this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n\n        return this.normalize();\n    }\n}\n","// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\n\n        if (!attr.buffer) {\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        const isNewBuffer = !attr.buffer;\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        if (isNewBuffer) {\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\n        } else {\n            this.gl.bufferSubData(attr.target, 0, attr.data);\n        }\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        // For drawElements, offset needs to be multiple of type size\n        let indexBytesPerElement = 2;\n        if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement\n                );\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) this.computeBoundingBox(attr);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        for (let key in this.VAOs) {\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n","// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\n\nlet ID = 1;\n\n// cache of typed arrays used to flatten uniform arrays\nconst arrayCacheF32 = {};\n\nexport class Program {\n    constructor(\n        gl,\n        {\n            vertex,\n            fragment,\n            uniforms = {},\n\n            transparent = false,\n            cullFace = gl.BACK,\n            frontFace = gl.CCW,\n            depthTest = true,\n            depthWrite = true,\n            depthFunc = gl.LEQUAL,\n        } = {}\n    ) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Program');\n        this.gl = gl;\n        this.uniforms = uniforms;\n        this.id = ID++;\n\n        if (!vertex) console.warn('vertex shader not supplied');\n        if (!fragment) console.warn('fragment shader not supplied');\n\n        // Store program state\n        this.transparent = transparent;\n        this.cullFace = cullFace;\n        this.frontFace = frontFace;\n        this.depthTest = depthTest;\n        this.depthWrite = depthWrite;\n        this.depthFunc = depthFunc;\n        this.blendFunc = {};\n        this.blendEquation = {};\n        this.stencilFunc = {};\n        this.stencilOp = {}\n\n        // set default blendFunc if transparent flagged\n        if (this.transparent && !this.blendFunc.src) {\n            if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n            else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        }\n\n        // Create empty shaders and attach to program\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, this.vertexShader);\n        gl.attachShader(this.program, this.fragmentShader);\n\n        // Compile shaders with source\n        this.setShaders({ vertex, fragment });\n    }\n\n    setShaders({ vertex, fragment }) {\n        if (vertex) {\n            // compile vertex shader and log errors\n            this.gl.shaderSource(this.vertexShader, vertex);\n            this.gl.compileShader(this.vertexShader);\n            if (this.gl.getShaderInfoLog(this.vertexShader) !== '') {\n                console.warn(`${this.gl.getShaderInfoLog(this.vertexShader)}\\nVertex Shader\\n${addLineNumbers(vertex)}`);\n            }\n        }\n\n        if (fragment) {\n            // compile fragment shader and log errors\n            this.gl.shaderSource(this.fragmentShader, fragment);\n            this.gl.compileShader(this.fragmentShader);\n            if (this.gl.getShaderInfoLog(this.fragmentShader) !== '') {\n                console.warn(`${this.gl.getShaderInfoLog(this.fragmentShader)}\\nFragment Shader\\n${addLineNumbers(fragment)}`);\n            }\n        }\n\n        // compile program and log errors\n        this.gl.linkProgram(this.program);\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            return console.warn(this.gl.getProgramInfoLog(this.program));\n        }\n\n        // Get active uniform locations\n        this.uniformLocations = new Map();\n        let numUniforms = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);\n        for (let uIndex = 0; uIndex < numUniforms; uIndex++) {\n            let uniform = this.gl.getActiveUniform(this.program, uIndex);\n            this.uniformLocations.set(uniform, this.gl.getUniformLocation(this.program, uniform.name));\n\n            // split uniforms' names to separate array and struct declarations\n            const split = uniform.name.match(/(\\w+)/g);\n\n            uniform.uniformName = split[0];\n            uniform.nameComponents = split.slice(1);\n        }\n\n        // Get active attribute locations\n        this.attributeLocations = new Map();\n        const locations = [];\n        const numAttribs = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);\n        for (let aIndex = 0; aIndex < numAttribs; aIndex++) {\n            const attribute = this.gl.getActiveAttrib(this.program, aIndex);\n            const location = this.gl.getAttribLocation(this.program, attribute.name);\n            // Ignore special built-in inputs. eg gl_VertexID, gl_InstanceID\n            if (location === -1) continue;\n            locations[location] = attribute.name;\n            this.attributeLocations.set(attribute, location);\n        }\n        this.attributeOrder = locations.join('');\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        this.blendFunc.src = src;\n        this.blendFunc.dst = dst;\n        this.blendFunc.srcAlpha = srcAlpha;\n        this.blendFunc.dstAlpha = dstAlpha;\n        if (src) this.transparent = true;\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        this.blendEquation.modeRGB = modeRGB;\n        this.blendEquation.modeAlpha = modeAlpha;\n    }\n\n    setStencilFunc(func, ref, mask) {\n        this.stencilRef = ref;\n        this.stencilFunc.func = func;\n        this.stencilFunc.ref = ref;\n        this.stencilFunc.mask = mask;\n    }\n\n    setStencilOp(stencilFail, depthFail, depthPass) {\n        this.stencilOp.stencilFail = stencilFail;\n        this.stencilOp.depthFail = depthFail;\n        this.stencilOp.depthPass = depthPass;\n    }\n\n    applyState() {\n        if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);\n        else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n\n        if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);\n        else this.gl.renderer.disable(this.gl.CULL_FACE);\n\n        if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);\n        else this.gl.renderer.disable(this.gl.BLEND);\n\n        if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n        this.gl.renderer.setFrontFace(this.frontFace);\n        this.gl.renderer.setDepthMask(this.depthWrite);\n        this.gl.renderer.setDepthFunc(this.depthFunc);\n        if (this.blendFunc.src) this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n        this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n\n        if(this.stencilFunc.func || this.stencilOp.stencilFail) this.gl.renderer.enable(this.gl.STENCIL_TEST)\n            else this.gl.renderer.disable(this.gl.STENCIL_TEST)\n\n        this.gl.renderer.setStencilFunc(this.stencilFunc.func, this.stencilFunc.ref, this.stencilFunc.mask)\n        this.gl.renderer.setStencilOp(this.stencilOp.stencilFail, this.stencilOp.depthFail, this.stencilOp.depthPass)\n\n    }\n\n    use({ flipFaces = false } = {}) {\n        let textureUnit = -1;\n        const programActive = this.gl.renderer.state.currentProgram === this.id;\n\n        // Avoid gl call if program already in use\n        if (!programActive) {\n            this.gl.useProgram(this.program);\n            this.gl.renderer.state.currentProgram = this.id;\n        }\n\n        // Set only the active uniforms found in the shader\n        this.uniformLocations.forEach((location, activeUniform) => {\n            let uniform = this.uniforms[activeUniform.uniformName];\n\n            for (const component of activeUniform.nameComponents) {\n                if (!uniform) break;\n\n                if (component in uniform) {\n                    uniform = uniform[component];\n                } else if (Array.isArray(uniform.value)) {\n                    break;\n                } else {\n                    uniform = undefined;\n                    break;\n                }\n            }\n\n            if (!uniform) {\n                return warn(`Active uniform ${activeUniform.name} has not been supplied`);\n            }\n\n            if (uniform && uniform.value === undefined) {\n                return warn(`${activeUniform.name} uniform is missing a value parameter`);\n            }\n\n            if (uniform.value.texture) {\n                textureUnit = textureUnit + 1;\n\n                // Check if texture needs to be updated\n                uniform.value.update(textureUnit);\n                return setUniform(this.gl, activeUniform.type, location, textureUnit);\n            }\n\n            // For texture arrays, set uniform as an array of texture units instead of just one\n            if (uniform.value.length && uniform.value[0].texture) {\n                const textureUnits = [];\n                uniform.value.forEach((value) => {\n                    textureUnit = textureUnit + 1;\n                    value.update(textureUnit);\n                    textureUnits.push(textureUnit);\n                });\n\n                return setUniform(this.gl, activeUniform.type, location, textureUnits);\n            }\n\n            setUniform(this.gl, activeUniform.type, location, uniform.value);\n        });\n\n        this.applyState();\n        if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n    }\n\n    remove() {\n        this.gl.deleteProgram(this.program);\n    }\n}\n\nfunction setUniform(gl, type, location, value) {\n    value = value.length ? flatten(value) : value;\n    const setValue = gl.renderer.state.uniformLocations.get(location);\n\n    // Avoid redundant uniform commands\n    if (value.length) {\n        if (setValue === undefined || setValue.length !== value.length) {\n            // clone array to store as cache\n            gl.renderer.state.uniformLocations.set(location, value.slice(0));\n        } else {\n            if (arraysEqual(setValue, value)) return;\n\n            // Update cached array values\n            setValue.set ? setValue.set(value) : setArray(setValue, value);\n            gl.renderer.state.uniformLocations.set(location, setValue);\n        }\n    } else {\n        if (setValue === value) return;\n        gl.renderer.state.uniformLocations.set(location, value);\n    }\n\n    switch (type) {\n        case 5126:\n            return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value); // FLOAT\n        case 35664:\n            return gl.uniform2fv(location, value); // FLOAT_VEC2\n        case 35665:\n            return gl.uniform3fv(location, value); // FLOAT_VEC3\n        case 35666:\n            return gl.uniform4fv(location, value); // FLOAT_VEC4\n        case 35670: // BOOL\n        case 5124: // INT\n        case 35678: // SAMPLER_2D\n        case 36306: // U_SAMPLER_2D\n        case 35680: // SAMPLER_CUBE\n        case 36289: // SAMPLER_2D_ARRAY\n            return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value); // SAMPLER_CUBE\n        case 35671: // BOOL_VEC2\n        case 35667:\n            return gl.uniform2iv(location, value); // INT_VEC2\n        case 35672: // BOOL_VEC3\n        case 35668:\n            return gl.uniform3iv(location, value); // INT_VEC3\n        case 35673: // BOOL_VEC4\n        case 35669:\n            return gl.uniform4iv(location, value); // INT_VEC4\n        case 35674:\n            return gl.uniformMatrix2fv(location, false, value); // FLOAT_MAT2\n        case 35675:\n            return gl.uniformMatrix3fv(location, false, value); // FLOAT_MAT3\n        case 35676:\n            return gl.uniformMatrix4fv(location, false, value); // FLOAT_MAT4\n    }\n}\n\nfunction addLineNumbers(string) {\n    let lines = string.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n        lines[i] = i + 1 + ': ' + lines[i];\n    }\n    return lines.join('\\n');\n}\n\nfunction flatten(a) {\n    const arrayLen = a.length;\n    const valueLen = a[0].length;\n    if (valueLen === undefined) return a;\n    const length = arrayLen * valueLen;\n    let value = arrayCacheF32[length];\n    if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n    for (let i = 0; i < arrayLen; i++) value.set(a[i], i * valueLen);\n    return value;\n}\n\nfunction arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\nfunction setArray(a, b) {\n    for (let i = 0, l = a.length; i < l; i++) {\n        a[i] = b[i];\n    }\n}\n\nlet warnCount = 0;\nfunction warn(message) {\n    if (warnCount > 100) return;\n    console.warn(message);\n    warnCount++;\n    if (warnCount > 100) console.warn('More than 100 program warnings - stopping logs.');\n}\n","import { Vec3 } from '../math/Vec3.js';\n\n// TODO: Handle context loss https://www.khronos.org/webgl/wiki/HandlingContextLost\n\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nlet ID = 1;\n\nexport class Renderer {\n    constructor({\n        canvas = document.createElement('canvas'),\n        width = 300,\n        height = 150,\n        dpr = 1,\n        alpha = false,\n        depth = true,\n        stencil = false,\n        antialias = false,\n        premultipliedAlpha = false,\n        preserveDrawingBuffer = false,\n        powerPreference = 'default',\n        autoClear = true,\n        webgl = 2,\n    } = {}) {\n        const attributes = { alpha, depth, stencil, antialias, premultipliedAlpha, preserveDrawingBuffer, powerPreference };\n        this.dpr = dpr;\n        this.alpha = alpha;\n        this.color = true;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.premultipliedAlpha = premultipliedAlpha;\n        this.autoClear = autoClear;\n        this.id = ID++;\n\n        // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n        if (webgl === 2) this.gl = canvas.getContext('webgl2', attributes);\n        this.isWebgl2 = !!this.gl;\n        if (!this.gl) this.gl = canvas.getContext('webgl', attributes);\n        if (!this.gl) console.error('unable to create webgl context');\n\n        // Attach renderer to gl so that all classes have access to internal state functions\n        this.gl.renderer = this;\n\n        // initialise size values\n        this.setSize(width, height);\n\n        // gl state stores to avoid redundant calls on methods used internally\n        this.state = {};\n        this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO };\n        this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD };\n        this.state.cullFace = false;\n        this.state.frontFace = this.gl.CCW;\n        this.state.depthMask = true;\n        this.state.depthFunc = this.gl.LEQUAL;\n        this.state.premultiplyAlpha = false;\n        this.state.flipY = false;\n        this.state.unpackAlignment = 4;\n        this.state.framebuffer = null;\n        this.state.viewport = { x: 0, y: 0, width: null, height: null };\n        this.state.textureUnits = [];\n        this.state.activeTextureUnit = 0;\n        this.state.boundBuffer = null;\n        this.state.uniformLocations = new Map();\n        this.state.currentProgram = null;\n\n        // store requested extensions\n        this.extensions = {};\n\n        // Initialise extra format types\n        if (this.isWebgl2) {\n            this.getExtension('EXT_color_buffer_float');\n            this.getExtension('OES_texture_float_linear');\n        } else {\n            this.getExtension('OES_texture_float');\n            this.getExtension('OES_texture_float_linear');\n            this.getExtension('OES_texture_half_float');\n            this.getExtension('OES_texture_half_float_linear');\n            this.getExtension('OES_element_index_uint');\n            this.getExtension('OES_standard_derivatives');\n            this.getExtension('EXT_sRGB');\n            this.getExtension('WEBGL_depth_texture');\n            this.getExtension('WEBGL_draw_buffers');\n        }\n        this.getExtension('WEBGL_compressed_texture_astc');\n        this.getExtension('EXT_texture_compression_bptc');\n        this.getExtension('WEBGL_compressed_texture_s3tc');\n        this.getExtension('WEBGL_compressed_texture_etc1');\n        this.getExtension('WEBGL_compressed_texture_pvrtc');\n        this.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\n        // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n        this.vertexAttribDivisor = this.getExtension('ANGLE_instanced_arrays', 'vertexAttribDivisor', 'vertexAttribDivisorANGLE');\n        this.drawArraysInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawArraysInstanced', 'drawArraysInstancedANGLE');\n        this.drawElementsInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawElementsInstanced', 'drawElementsInstancedANGLE');\n        this.createVertexArray = this.getExtension('OES_vertex_array_object', 'createVertexArray', 'createVertexArrayOES');\n        this.bindVertexArray = this.getExtension('OES_vertex_array_object', 'bindVertexArray', 'bindVertexArrayOES');\n        this.deleteVertexArray = this.getExtension('OES_vertex_array_object', 'deleteVertexArray', 'deleteVertexArrayOES');\n        this.drawBuffers = this.getExtension('WEBGL_draw_buffers', 'drawBuffers', 'drawBuffersWEBGL');\n\n        // Store device parameters\n        this.parameters = {};\n        this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n        this.parameters.maxAnisotropy = this.getExtension('EXT_texture_filter_anisotropic')\n            ? this.gl.getParameter(this.getExtension('EXT_texture_filter_anisotropic').MAX_TEXTURE_MAX_ANISOTROPY_EXT)\n            : 0;\n    }\n\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        this.gl.canvas.width = width * this.dpr;\n        this.gl.canvas.height = height * this.dpr;\n\n        if (!this.gl.canvas.style) return;\n        Object.assign(this.gl.canvas.style, {\n            width: width + 'px',\n            height: height + 'px',\n        });\n    }\n\n    setViewport(width, height, x = 0, y = 0) {\n        if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n        this.state.viewport.width = width;\n        this.state.viewport.height = height;\n        this.state.viewport.x = x;\n        this.state.viewport.y = y;\n        this.gl.viewport(x, y, width, height);\n    }\n\n    setScissor(width, height, x = 0, y = 0) {\n        this.gl.scissor(x, y, width, height);\n    }\n\n    enable(id) {\n        if (this.state[id] === true) return;\n        this.gl.enable(id);\n        this.state[id] = true;\n    }\n\n    disable(id) {\n        if (this.state[id] === false) return;\n        this.gl.disable(id);\n        this.state[id] = false;\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        if (\n            this.state.blendFunc.src === src &&\n            this.state.blendFunc.dst === dst &&\n            this.state.blendFunc.srcAlpha === srcAlpha &&\n            this.state.blendFunc.dstAlpha === dstAlpha\n        )\n            return;\n        this.state.blendFunc.src = src;\n        this.state.blendFunc.dst = dst;\n        this.state.blendFunc.srcAlpha = srcAlpha;\n        this.state.blendFunc.dstAlpha = dstAlpha;\n        if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);\n        else this.gl.blendFunc(src, dst);\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        modeRGB = modeRGB || this.gl.FUNC_ADD;\n        if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n        this.state.blendEquation.modeRGB = modeRGB;\n        this.state.blendEquation.modeAlpha = modeAlpha;\n        if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);\n        else this.gl.blendEquation(modeRGB);\n    }\n\n    setCullFace(value) {\n        if (this.state.cullFace === value) return;\n        this.state.cullFace = value;\n        this.gl.cullFace(value);\n    }\n\n    setFrontFace(value) {\n        if (this.state.frontFace === value) return;\n        this.state.frontFace = value;\n        this.gl.frontFace(value);\n    }\n\n    setDepthMask(value) {\n        if (this.state.depthMask === value) return;\n        this.state.depthMask = value;\n        this.gl.depthMask(value);\n    }\n\n    setDepthFunc(value) {\n        if (this.state.depthFunc === value) return;\n        this.state.depthFunc = value;\n        this.gl.depthFunc(value);\n    }\n\n    setStencilMask(value) {\n        if(this.state.stencilMask === value) return;\n        this.state.stencilMask = value;\n        this.gl.stencilMask(value)\n    }\n\n    setStencilFunc(func, ref, mask) {\n\n        if((this.state.stencilFunc === func) &&\n            (this.state.stencilRef === ref) &&\n            (this.state.stencilFuncMask === mask)\n        ) return;\n\n        this.state.stencilFunc = func || this.gl.ALWAYS;\n        this.state.stencilRef = ref || 0;\n        this.state.stencilFuncMask = mask || 0;\n\n        this.gl.stencilFunc(func || this.gl.ALWAYS, ref || 0, mask || 0);\n    }\n\n    setStencilOp(stencilFail, depthFail, depthPass) {\n\n        if(this.state.stencilFail === stencilFail &&\n            this.state.stencilDepthFail === depthFail &&\n            this.state.stencilDepthPass === depthPass\n        ) return;\n\n        this.state.stencilFail = stencilFail;\n        this.state.stencilDepthFail = depthFail;\n        this.state.stencilDepthPass = depthPass;\n        \n        this.gl.stencilOp(stencilFail, depthFail, depthPass);\n        \n    }\n\n    activeTexture(value) {\n        if (this.state.activeTextureUnit === value) return;\n        this.state.activeTextureUnit = value;\n        this.gl.activeTexture(this.gl.TEXTURE0 + value);\n    }\n\n    bindFramebuffer({ target = this.gl.FRAMEBUFFER, buffer = null } = {}) {\n        if (this.state.framebuffer === buffer) return;\n        this.state.framebuffer = buffer;\n        this.gl.bindFramebuffer(target, buffer);\n    }\n\n    getExtension(extension, webgl2Func, extFunc) {\n        // if webgl2 function supported, return func bound to gl context\n        if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl);\n\n        // fetch extension once only\n        if (!this.extensions[extension]) {\n            this.extensions[extension] = this.gl.getExtension(extension);\n        }\n\n        // return extension if no function requested\n        if (!webgl2Func) return this.extensions[extension];\n\n        // Return null if extension not supported\n        if (!this.extensions[extension]) return null;\n\n        // return extension function, bound to extension\n        return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n    }\n\n    sortOpaque(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else if (a.zDepth !== b.zDepth) {\n            return a.zDepth - b.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortTransparent(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        }\n        if (a.zDepth !== b.zDepth) {\n            return b.zDepth - a.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortUI(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    getRenderList({ scene, camera, frustumCull, sort }) {\n        let renderList = [];\n\n        if (camera && frustumCull) camera.updateFrustum();\n\n        // Get visible\n        scene.traverse((node) => {\n            if (!node.visible) return true;\n            if (!node.draw) return;\n\n            if (frustumCull && node.frustumCulled && camera) {\n                if (!camera.frustumIntersectsMesh(node)) return;\n            }\n\n            renderList.push(node);\n        });\n\n        if (sort) {\n            const opaque = [];\n            const transparent = []; // depthTest true\n            const ui = []; // depthTest false\n\n            renderList.forEach((node) => {\n                // Split into the 3 render groups\n                if (!node.program.transparent) {\n                    opaque.push(node);\n                } else if (node.program.depthTest) {\n                    transparent.push(node);\n                } else {\n                    ui.push(node);\n                }\n\n                node.zDepth = 0;\n\n                // Only calculate z-depth if renderOrder unset and depthTest is true\n                if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return;\n\n                // update z-depth\n                node.worldMatrix.getTranslation(tempVec3);\n                tempVec3.applyMatrix4(camera.projectionViewMatrix);\n                node.zDepth = tempVec3.z;\n            });\n\n            opaque.sort(this.sortOpaque);\n            transparent.sort(this.sortTransparent);\n            ui.sort(this.sortUI);\n\n            renderList = opaque.concat(transparent, ui);\n        }\n\n        return renderList;\n    }\n\n    render({ scene, camera, target = null, update = true, sort = true, frustumCull = true, clear }) {\n        if (target === null) {\n            // make sure no render target bound so draws to canvas\n            this.bindFramebuffer();\n            this.setViewport(this.width * this.dpr, this.height * this.dpr);\n        } else {\n            // bind supplied render target and update viewport\n            this.bindFramebuffer(target);\n            this.setViewport(target.width, target.height);\n        }\n\n        if (clear || (this.autoClear && clear !== false)) {\n            // Ensure depth buffer writing is enabled so it can be cleared\n            if (this.depth && (!target || target.depth)) {\n                this.enable(this.gl.DEPTH_TEST);\n                this.setDepthMask(true);\n            }\n\n            // Same for stencil\n            if(this.stencil || (!target || target.stencil)) {\n                this.enable(this.gl.STENCIL_TEST);\n                this.setStencilMask(0xff)\n            }\n\n            this.gl.clear(\n                (this.color ? this.gl.COLOR_BUFFER_BIT : 0) |\n                    (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) |\n                    (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)\n            );\n        }\n\n        // updates all scene graph matrices\n        if (update) scene.updateMatrixWorld();\n\n        // Update camera separately, in case not in scene graph\n        if (camera) camera.updateMatrixWorld();\n\n        // Get render list - entails culling and sorting\n        const renderList = this.getRenderList({ scene, camera, frustumCull, sort });\n\n        renderList.forEach((node) => {\n            node.draw({ camera });\n        });\n    }\n}\n","const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    let len = x * x + y * y + z * z + w * w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = x * len;\n    out[1] = y * len;\n    out[2] = z * len;\n    out[3] = w * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    let aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n}\n","import * as vec4 from './Vec4Func.js';\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n}\n\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let by = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bz = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n\n    return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n    let a0 = a[0],\n        a1 = a[1],\n        a2 = a[2],\n        a3 = a[3];\n    let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    let invDot = dot ? 1.0 / dot : 0;\n\n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0); // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot; // 1/(4w)\n        out[0] = (m[5] - m[7]) * fRoot;\n        out[1] = (m[6] - m[2]) * fRoot;\n        out[2] = (m[1] - m[3]) * fRoot;\n    } else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[4] > m[0]) i = 1;\n        if (m[8] > m[i * 3 + i]) i = 2;\n        let j = (i + 1) % 3;\n        let k = (i + 2) % 3;\n\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n\n    return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, euler, order = 'YXZ') {\n    let sx = Math.sin(euler[0] * 0.5);\n    let cx = Math.cos(euler[0] * 0.5);\n    let sy = Math.sin(euler[1] * 0.5);\n    let cy = Math.cos(euler[1] * 0.5);\n    let sz = Math.sin(euler[2] * 0.5);\n    let cz = Math.cos(euler[2] * 0.5);\n\n    if (order === 'XYZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'YXZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'ZXY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'ZYX') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'YZX') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'XZY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    }\n\n    return out;\n}\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport const copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport const set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport const add = vec4.add;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport const scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nexport const lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport const length = vec4.length;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport const normalize = vec4.normalize;\n","import * as QuatFunc from './functions/QuatFunc.js';\n\nexport class Quat extends Array {\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        super(x, y, z, w);\n        this.onChange = () => {};\n\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = ['0', '1', '2', '3'];\n        return new Proxy(this, {\n            set(target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            },\n        });\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n\n    set w(v) {\n        this._target[3] = v;\n        this.onChange();\n    }\n\n    identity() {\n        QuatFunc.identity(this._target);\n        this.onChange();\n        return this;\n    }\n\n    set(x, y, z, w) {\n        if (x.length) return this.copy(x);\n        QuatFunc.set(this._target, x, y, z, w);\n        this.onChange();\n        return this;\n    }\n\n    rotateX(a) {\n        QuatFunc.rotateX(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateY(a) {\n        QuatFunc.rotateY(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateZ(a) {\n        QuatFunc.rotateZ(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    inverse(q = this._target) {\n        QuatFunc.invert(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    conjugate(q = this._target) {\n        QuatFunc.conjugate(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    copy(q) {\n        QuatFunc.copy(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    normalize(q = this._target) {\n        QuatFunc.normalize(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    multiply(qA, qB) {\n        if (qB) {\n            QuatFunc.multiply(this._target, qA, qB);\n        } else {\n            QuatFunc.multiply(this._target, this._target, qA);\n        }\n        this.onChange();\n        return this;\n    }\n\n    dot(v) {\n        return QuatFunc.dot(this._target, v);\n    }\n\n    fromMatrix3(matrix3) {\n        QuatFunc.fromMat3(this._target, matrix3);\n        this.onChange();\n        return this;\n    }\n\n    fromEuler(euler, isInternal) {\n        QuatFunc.fromEuler(this._target, euler, euler.order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n\n    fromAxisAngle(axis, a) {\n        QuatFunc.setAxisAngle(this._target, axis, a);\n        this.onChange();\n        return this;\n    }\n\n    slerp(q, t) {\n        QuatFunc.slerp(this._target, this._target, q, t);\n        this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        this._target[3] = a[o + 3];\n        this.onChange();\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n","import * as vec3 from './Vec3Func.js';\n\nconst EPSILON = 0.000001;\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a03 = a[3];\n        let a12 = a[6],\n            a13 = a[7];\n        let a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    let b0 = b[0],\n        b1 = b[1],\n        b2 = b[2],\n        b3 = b[3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function translate(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11];\n\n        out[0] = a00;\n        out[1] = a01;\n        out[2] = a02;\n        out[3] = a03;\n        out[4] = a10;\n        out[5] = a11;\n        out[6] = a12;\n        out[7] = a13;\n        out[8] = a20;\n        out[9] = a21;\n        out[10] = a22;\n        out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function rotate(out, a, rad, axis) {\n    let x = axis[0],\n        y = axis[1],\n        z = axis[2];\n    let len = Math.hypot(x, y, z);\n    let s, c, t;\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    let b00, b01, b02;\n    let b10, b11, b12;\n    let b20, b21, b22;\n\n    if (Math.abs(len) < EPSILON) {\n        return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c;\n    b01 = y * x * t + z * s;\n    b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s;\n    b11 = y * y * t + c;\n    b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s;\n    b21 = y * z * t - x * s;\n    b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) {\n        // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n\n    return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n\n    return out;\n}\n\nexport function getMaxScaleOnAxis(mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    const x = m11 * m11 + m12 * m12 + m13 * m13;\n    const y = m21 * m21 + m22 * m22 + m23 * m23;\n    const z = m31 * m31 + m32 * m32 + m33 * m33;\n\n    return Math.sqrt(Math.max(x, y, z));\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nexport const getRotation = (function () {\n    const temp = [1, 1, 1];\n\n    return function (out, mat) {\n        let scaling = temp;\n        getScaling(scaling, mat);\n\n        let is1 = 1 / scaling[0];\n        let is2 = 1 / scaling[1];\n        let is3 = 1 / scaling[2];\n\n        let sm11 = mat[0] * is1;\n        let sm12 = mat[1] * is2;\n        let sm13 = mat[2] * is3;\n        let sm21 = mat[4] * is1;\n        let sm22 = mat[5] * is2;\n        let sm23 = mat[6] * is3;\n        let sm31 = mat[8] * is1;\n        let sm32 = mat[9] * is2;\n        let sm33 = mat[10] * is3;\n\n        let trace = sm11 + sm22 + sm33;\n        let S = 0;\n\n        if (trace > 0) {\n            S = Math.sqrt(trace + 1.0) * 2;\n            out[3] = 0.25 * S;\n            out[0] = (sm23 - sm32) / S;\n            out[1] = (sm31 - sm13) / S;\n            out[2] = (sm12 - sm21) / S;\n        } else if (sm11 > sm22 && sm11 > sm33) {\n            S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n            out[3] = (sm23 - sm32) / S;\n            out[0] = 0.25 * S;\n            out[1] = (sm12 + sm21) / S;\n            out[2] = (sm31 + sm13) / S;\n        } else if (sm22 > sm33) {\n            S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n            out[3] = (sm31 - sm13) / S;\n            out[0] = (sm12 + sm21) / S;\n            out[1] = 0.25 * S;\n            out[2] = (sm23 + sm32) / S;\n        } else {\n            S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n            out[3] = (sm12 - sm21) / S;\n            out[0] = (sm31 + sm13) / S;\n            out[1] = (sm23 + sm32) / S;\n            out[2] = 0.25 * S;\n        }\n\n        return out;\n    };\n})();\n\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Decompose a mat4 to TRS properties.\n *\n * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} srcMat Matrix element, to be decomposed to TRS properties.\n * @param {quat4} dstRotation Rotation element, to be overwritten.\n * @param {vec3} dstTranslation Translation element, to be overwritten.\n * @param {vec3} dstScale Scale element, to be overwritten\n */\nexport function decompose(srcMat, dstRotation, dstTranslation, dstScale) {\n    let sx = vec3.length([srcMat[0], srcMat[1], srcMat[2]]);\n    const sy = vec3.length([srcMat[4], srcMat[5], srcMat[6]]);\n    const sz = vec3.length([srcMat[8], srcMat[9], srcMat[10]]);\n\n    // if determine is negative, we need to invert one scale\n    const det = determinant(srcMat);\n    if (det < 0) sx = -sx;\n\n    dstTranslation[0] = srcMat[12];\n    dstTranslation[1] = srcMat[13];\n    dstTranslation[2] = srcMat[14];\n\n    // scale the rotation part\n    const _m1 = srcMat.slice();\n\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n\n    _m1[0] *= invSX;\n    _m1[1] *= invSX;\n    _m1[2] *= invSX;\n\n    _m1[4] *= invSY;\n    _m1[5] *= invSY;\n    _m1[6] *= invSY;\n\n    _m1[8] *= invSZ;\n    _m1[9] *= invSZ;\n    _m1[10] *= invSZ;\n\n    getRotation(dstRotation, _m1);\n\n    dstScale[0] = sx;\n    dstScale[1] = sy;\n    dstScale[2] = sz;\n}\n\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Compose TRS properties to a mat4.\n *\n * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} dstMat Matrix element, to be modified and returned.\n * @param {quat4} srcRotation Rotation element of matrix.\n * @param {vec3} srcTranslation Translation element of matrix.\n * @param {vec3} srcScale Scale element of matrix.\n * @returns {mat4} dstMat, overwritten to mat4 equivalent of given TRS properties.\n */\nexport function compose(dstMat, srcRotation, srcTranslation, srcScale) {\n    const te = dstMat;\n\n    const x = srcRotation[0],\n        y = srcRotation[1],\n        z = srcRotation[2],\n        w = srcRotation[3];\n    const x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    const xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    const yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    const wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    const sx = srcScale[0],\n        sy = srcScale[1],\n        sz = srcScale[2];\n\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n\n    te[12] = srcTranslation[0];\n    te[13] = srcTranslation[1];\n    te[14] = srcTranslation[2];\n    te[15] = 1;\n\n    return te;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScale(out, q, v, s) {\n    // Quaternion math\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = s[0];\n    let sy = s[1];\n    let sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function perspective(out, fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2);\n    let nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 2 * far * near * nf;\n    out[15] = 0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function ortho(out, left, right, bottom, top, near, far) {\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function targetTo(out, eye, target, up) {\n    let eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2];\n\n    let z0 = eyex - target[0],\n        z1 = eyey - target[1],\n        z2 = eyez - target[2];\n\n    let len = z0 * z0 + z1 * z1 + z2 * z2;\n    if (len === 0) {\n        // eye and target are in the same position\n        z2 = 1;\n    } else {\n        len = 1 / Math.sqrt(len);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n    }\n\n    let x0 = upy * z2 - upz * z1,\n        x1 = upz * z0 - upx * z2,\n        x2 = upx * z1 - upy * z0;\n\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n    if (len === 0) {\n        // up and z are parallel\n        if (upz) {\n            upx += 1e-6;\n        } else if (upy) {\n            upz += 1e-6;\n        } else {\n            upy += 1e-6;\n        }\n        (x0 = upy * z2 - upz * z1), (x1 = upz * z0 - upx * z2), (x2 = upx * z1 - upy * z0);\n\n        len = x0 * x0 + x1 * x1 + x2 * x2;\n    }\n\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n\n    out[0] = x0;\n    out[1] = x1;\n    out[2] = x2;\n    out[3] = 0;\n    out[4] = z1 * x2 - z2 * x1;\n    out[5] = z2 * x0 - z0 * x2;\n    out[6] = z0 * x1 - z1 * x0;\n    out[7] = 0;\n    out[8] = z0;\n    out[9] = z1;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = eyex;\n    out[13] = eyey;\n    out[14] = eyez;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n}\n","import * as Mat4Func from './functions/Mat4Func.js';\n\nexport class Mat4 extends Array {\n    constructor(\n        m00 = 1,\n        m01 = 0,\n        m02 = 0,\n        m03 = 0,\n        m10 = 0,\n        m11 = 1,\n        m12 = 0,\n        m13 = 0,\n        m20 = 0,\n        m21 = 0,\n        m22 = 1,\n        m23 = 0,\n        m30 = 0,\n        m31 = 0,\n        m32 = 0,\n        m33 = 1\n    ) {\n        super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    get x() {\n        return this[12];\n    }\n\n    get y() {\n        return this[13];\n    }\n\n    get z() {\n        return this[14];\n    }\n\n    get w() {\n        return this[15];\n    }\n\n    set x(v) {\n        this[12] = v;\n    }\n\n    set y(v) {\n        this[13] = v;\n    }\n\n    set z(v) {\n        this[14] = v;\n    }\n\n    set w(v) {\n        this[15] = v;\n    }\n\n    set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n        if (m00.length) return this.copy(m00);\n        Mat4Func.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat4Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, axis, m = this) {\n        Mat4Func.rotate(this, m, v, axis);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat4Func.scale(this, m, typeof v === 'number' ? [v, v, v] : v);\n        return this;\n    }\n\n    add(ma, mb) {\n        if (mb) Mat4Func.add(this, ma, mb);\n        else Mat4Func.add(this, this, ma);\n        return this;\n    }\n\n    sub(ma, mb) {\n        if (mb) Mat4Func.subtract(this, ma, mb);\n        else Mat4Func.subtract(this, this, ma);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (!ma.length) {\n            Mat4Func.multiplyScalar(this, this, ma);\n        } else if (mb) {\n            Mat4Func.multiply(this, ma, mb);\n        } else {\n            Mat4Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat4Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat4Func.copy(this, m);\n        return this;\n    }\n\n    fromPerspective({ fov, aspect, near, far } = {}) {\n        Mat4Func.perspective(this, fov, aspect, near, far);\n        return this;\n    }\n\n    fromOrthogonal({ left, right, bottom, top, near, far }) {\n        Mat4Func.ortho(this, left, right, bottom, top, near, far);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat4Func.fromQuat(this, q);\n        return this;\n    }\n\n    setPosition(v) {\n        this.x = v[0];\n        this.y = v[1];\n        this.z = v[2];\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat4Func.invert(this, m);\n        return this;\n    }\n\n    compose(q, pos, scale) {\n        Mat4Func.compose(this, q, pos, scale);\n        return this;\n    }\n\n    decompose(q, pos, scale) {\n        Mat4Func.decompose(this, q, pos, scale);\n        return this;\n    }\n\n    getRotation(q) {\n        Mat4Func.getRotation(q, this);\n        return this;\n    }\n\n    getTranslation(pos) {\n        Mat4Func.getTranslation(pos, this);\n        return this;\n    }\n\n    getScaling(scale) {\n        Mat4Func.getScaling(scale, this);\n        return this;\n    }\n\n    getMaxScaleOnAxis() {\n        return Mat4Func.getMaxScaleOnAxis(this);\n    }\n\n    lookAt(eye, target, up) {\n        Mat4Func.targetTo(this, eye, target, up);\n        return this;\n    }\n\n    determinant() {\n        return Mat4Func.determinant(this);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        this[4] = a[o + 4];\n        this[5] = a[o + 5];\n        this[6] = a[o + 6];\n        this[7] = a[o + 7];\n        this[8] = a[o + 8];\n        this[9] = a[o + 9];\n        this[10] = a[o + 10];\n        this[11] = a[o + 11];\n        this[12] = a[o + 12];\n        this[13] = a[o + 13];\n        this[14] = a[o + 14];\n        this[15] = a[o + 15];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        a[o + 4] = this[4];\n        a[o + 5] = this[5];\n        a[o + 6] = this[6];\n        a[o + 7] = this[7];\n        a[o + 8] = this[8];\n        a[o + 9] = this[9];\n        a[o + 10] = this[10];\n        a[o + 11] = this[11];\n        a[o + 12] = this[12];\n        a[o + 13] = this[13];\n        a[o + 14] = this[14];\n        a[o + 15] = this[15];\n        return a;\n    }\n}\n","// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nexport function fromRotationMatrix(out, m, order = 'YXZ') {\n    if (order === 'XYZ') {\n        out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n        if (Math.abs(m[8]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[2] = Math.atan2(-m[4], m[0]);\n        } else {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[2] = 0;\n        }\n    } else if (order === 'YXZ') {\n        out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n        if (Math.abs(m[9]) < 0.99999) {\n            out[1] = Math.atan2(m[8], m[10]);\n            out[2] = Math.atan2(m[1], m[5]);\n        } else {\n            out[1] = Math.atan2(-m[2], m[0]);\n            out[2] = 0;\n        }\n    } else if (order === 'ZXY') {\n        out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n        if (Math.abs(m[6]) < 0.99999) {\n            out[1] = Math.atan2(-m[2], m[10]);\n            out[2] = Math.atan2(-m[4], m[5]);\n        } else {\n            out[1] = 0;\n            out[2] = Math.atan2(m[1], m[0]);\n        }\n    } else if (order === 'ZYX') {\n        out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n        if (Math.abs(m[2]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[10]);\n            out[2] = Math.atan2(m[1], m[0]);\n        } else {\n            out[0] = 0;\n            out[2] = Math.atan2(-m[4], m[5]);\n        }\n    } else if (order === 'YZX') {\n        out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n        if (Math.abs(m[1]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[5]);\n            out[1] = Math.atan2(-m[2], m[0]);\n        } else {\n            out[0] = 0;\n            out[1] = Math.atan2(m[8], m[10]);\n        }\n    } else if (order === 'XZY') {\n        out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n        if (Math.abs(m[4]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[1] = Math.atan2(m[8], m[0]);\n        } else {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[1] = 0;\n        }\n    }\n\n    return out;\n}\n","import * as EulerFunc from './functions/EulerFunc.js';\nimport { Mat4 } from './Mat4.js';\n\nconst tmpMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Euler extends Array {\n    constructor(x = 0, y = x, z = x, order = 'YXZ') {\n        super(x, y, z);\n        this.order = order;\n        this.onChange = () => {};\n\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = ['0', '1', '2'];\n        return new Proxy(this, {\n            set(target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            },\n        });\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        this._target[0] = x;\n        this._target[1] = y;\n        this._target[2] = z;\n        this.onChange();\n        return this;\n    }\n\n    copy(v) {\n        this._target[0] = v[0];\n        this._target[1] = v[1];\n        this._target[2] = v[2];\n        this.onChange();\n        return this;\n    }\n\n    reorder(order) {\n        this._target.order = order;\n        this.onChange();\n        return this;\n    }\n\n    fromRotationMatrix(m, order = this.order) {\n        EulerFunc.fromRotationMatrix(this._target, m, order);\n        this.onChange();\n        return this;\n    }\n\n    fromQuaternion(q, order = this.order, isInternal) {\n        tmpMat4.fromQuaternion(q);\n        this._target.fromRotationMatrix(tmpMat4, order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n}\n","import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Euler } from '../math/Euler.js';\n\nexport class Transform {\n    constructor() {\n        this.parent = null;\n        this.children = [];\n        this.visible = true;\n\n        this.matrix = new Mat4();\n        this.worldMatrix = new Mat4();\n        this.matrixAutoUpdate = true;\n        this.worldMatrixNeedsUpdate = false;\n\n        this.position = new Vec3();\n        this.quaternion = new Quat();\n        this.scale = new Vec3(1);\n        this.rotation = new Euler();\n        this.up = new Vec3(0, 1, 0);\n\n        this.rotation._target.onChange = () => this.quaternion.fromEuler(this.rotation, true);\n        this.quaternion._target.onChange = () => this.rotation.fromQuaternion(this.quaternion, undefined, true);\n    }\n\n    setParent(parent, notifyParent = true) {\n        if (this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n        this.parent = parent;\n        if (notifyParent && parent) parent.addChild(this, false);\n    }\n\n    addChild(child, notifyChild = true) {\n        if (!~this.children.indexOf(child)) this.children.push(child);\n        if (notifyChild) child.setParent(this, false);\n    }\n\n    removeChild(child, notifyChild = true) {\n        if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n        if (notifyChild) child.setParent(null, false);\n    }\n\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n        if (this.worldMatrixNeedsUpdate || force) {\n            if (this.parent === null) this.worldMatrix.copy(this.matrix);\n            else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n            this.worldMatrixNeedsUpdate = false;\n            force = true;\n        }\n\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].updateMatrixWorld(force);\n        }\n    }\n\n    updateMatrix() {\n        this.matrix.compose(this.quaternion, this.position, this.scale);\n        this.worldMatrixNeedsUpdate = true;\n    }\n\n    traverse(callback) {\n        // Return true in callback to stop traversing children\n        if (callback(this)) return;\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].traverse(callback);\n        }\n    }\n\n    decompose() {\n        this.matrix.decompose(this.quaternion._target, this.position, this.scale);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n\n    lookAt(target, invert = false) {\n        if (invert) this.matrix.lookAt(this.position, target, this.up);\n        else this.matrix.lookAt(target, this.position, this.up);\n        this.matrix.getRotation(this.quaternion._target);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n}\n","import { Transform } from './Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\n\nexport class Camera extends Transform {\n    constructor(gl, { near = 0.1, far = 100, fov = 45, aspect = 1, left, right, bottom, top, zoom = 1 } = {}) {\n        super();\n\n        Object.assign(this, { near, far, fov, aspect, left, right, bottom, top, zoom });\n\n        this.projectionMatrix = new Mat4();\n        this.viewMatrix = new Mat4();\n        this.projectionViewMatrix = new Mat4();\n        this.worldPosition = new Vec3();\n\n        // Use orthographic if left/right set, else default to perspective camera\n        this.type = left || right ? 'orthographic' : 'perspective';\n\n        if (this.type === 'orthographic') this.orthographic();\n        else this.perspective();\n    }\n\n    perspective({ near = this.near, far = this.far, fov = this.fov, aspect = this.aspect } = {}) {\n        Object.assign(this, { near, far, fov, aspect });\n        this.projectionMatrix.fromPerspective({ fov: fov * (Math.PI / 180), aspect, near, far });\n        this.type = 'perspective';\n        return this;\n    }\n\n    orthographic({\n        near = this.near,\n        far = this.far,\n        left = this.left || -1,\n        right = this.right || 1,\n        bottom = this.bottom || -1,\n        top = this.top || 1,\n        zoom = this.zoom,\n    } = {}) {\n        Object.assign(this, { near, far, left, right, bottom, top, zoom });\n        left /= zoom;\n        right /= zoom;\n        bottom /= zoom;\n        top /= zoom;\n        this.projectionMatrix.fromOrthogonal({ left, right, bottom, top, near, far });\n        this.type = 'orthographic';\n        return this;\n    }\n\n    updateMatrixWorld() {\n        super.updateMatrixWorld();\n        this.viewMatrix.inverse(this.worldMatrix);\n        this.worldMatrix.getTranslation(this.worldPosition);\n\n        // used for sorting\n        this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n        return this;\n    }\n\n    updateProjectionMatrix() {\n        if (this.type === 'perspective') {\n            return this.perspective();\n        } else {\n            return this.orthographic();\n        }\n    }\n\n    lookAt(target) {\n        super.lookAt(target, true);\n        return this;\n    }\n\n    // Project 3D coordinate to 2D point\n    project(v) {\n        v.applyMatrix4(this.viewMatrix);\n        v.applyMatrix4(this.projectionMatrix);\n        return this;\n    }\n\n    // Unproject 2D point to 3D coordinate\n    unproject(v) {\n        v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n        v.applyMatrix4(this.worldMatrix);\n        return this;\n    }\n\n    updateFrustum() {\n        if (!this.frustum) {\n            this.frustum = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n        }\n\n        const m = this.projectionViewMatrix;\n        this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n        this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n        this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n        this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n        this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n        this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n\n        for (let i = 0; i < 6; i++) {\n            const invLen = 1.0 / this.frustum[i].distance();\n            this.frustum[i].multiply(invLen);\n            this.frustum[i].constant *= invLen;\n        }\n    }\n\n    frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {\n        // If no position attribute, treat as frustumCulled false\n        if (!node.geometry.attributes.position) return true;\n\n        if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n\n        if (!node.geometry.bounds) return true;\n\n        const center = tempVec3a;\n        center.copy(node.geometry.bounds.center);\n        center.applyMatrix4(worldMatrix);\n\n        const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();\n\n        return this.frustumIntersectsSphere(center, radius);\n    }\n\n    frustumIntersectsSphere(center, radius) {\n        const normal = tempVec3b;\n\n        for (let i = 0; i < 6; i++) {\n            const plane = this.frustum[i];\n            const distance = normal.copy(plane).dot(center) + plane.constant;\n            if (distance < -radius) return false;\n        }\n        return true;\n    }\n}\n","const EPSILON = 0.000001;\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b01 = a22 * a11 - a12 * a21;\n    let b11 = -a22 * a10 + a12 * a20;\n    let b21 = a21 * a10 - a11 * a20;\n\n    // Calculate the determinant\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b00 = b[0],\n        b01 = b[1],\n        b02 = b[2];\n    let b10 = b[3],\n        b11 = b[4],\n        b12 = b[5];\n    let b20 = b[6],\n        b21 = b[7],\n        b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        x = v[0],\n        y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n}\n","import * as Mat3Func from './functions/Mat3Func.js';\n\nexport class Mat3 extends Array {\n    constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {\n        super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        if (m00.length) return this.copy(m00);\n        Mat3Func.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat3Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, m = this) {\n        Mat3Func.rotate(this, m, v);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat3Func.scale(this, m, v);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (mb) {\n            Mat3Func.multiply(this, ma, mb);\n        } else {\n            Mat3Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat3Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat3Func.copy(this, m);\n        return this;\n    }\n\n    fromMatrix4(m) {\n        Mat3Func.fromMat4(this, m);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat3Func.fromQuat(this, q);\n        return this;\n    }\n\n    fromBasis(vec3a, vec3b, vec3c) {\n        this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat3Func.invert(this, m);\n        return this;\n    }\n\n    getNormalMatrix(m) {\n        Mat3Func.normalFromMat4(this, m);\n        return this;\n    }\n}\n","import { Transform } from './Transform.js';\nimport { Mat3 } from '../math/Mat3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nlet ID = 0;\n\nexport class Mesh extends Transform {\n    constructor(gl, { geometry, program, mode = gl.TRIANGLES, frustumCulled = true, renderOrder = 0 } = {}) {\n        super();\n        if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n        this.gl = gl;\n        this.id = ID++;\n        this.geometry = geometry;\n        this.program = program;\n        this.mode = mode;\n\n        // Used to skip frustum culling\n        this.frustumCulled = frustumCulled;\n\n        // Override sorting to force an order\n        this.renderOrder = renderOrder;\n        this.modelViewMatrix = new Mat4();\n        this.normalMatrix = new Mat3();\n        this.beforeRenderCallbacks = [];\n        this.afterRenderCallbacks = [];\n    }\n\n    onBeforeRender(f) {\n        this.beforeRenderCallbacks.push(f);\n        return this;\n    }\n\n    onAfterRender(f) {\n        this.afterRenderCallbacks.push(f);\n        return this;\n    }\n\n    draw({ camera } = {}) {\n        if (camera) {\n            // Add empty matrix uniforms to program if unset\n            if (!this.program.uniforms.modelMatrix) {\n                Object.assign(this.program.uniforms, {\n                    modelMatrix: { value: null },\n                    viewMatrix: { value: null },\n                    modelViewMatrix: { value: null },\n                    normalMatrix: { value: null },\n                    projectionMatrix: { value: null },\n                    cameraPosition: { value: null },\n                });\n            }\n\n            // Set the matrix uniforms\n            this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n            this.program.uniforms.cameraPosition.value = camera.worldPosition;\n            this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n            this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n            this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n            this.program.uniforms.modelMatrix.value = this.worldMatrix;\n            this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n            this.program.uniforms.normalMatrix.value = this.normalMatrix;\n        }\n        this.beforeRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n\n        // determine if faces need to be flipped - when mesh scaled negatively\n        let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n        this.program.use({ flipFaces });\n        this.geometry.draw({ mode: this.mode, program: this.program });\n        this.afterRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n    }\n}\n","// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n            length = 1,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.wrapR = wrapR;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.length = length;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.wrapR !== this.state.wrapR) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n            this.state.wrapR = this.wrapR;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n                } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n                }\n            } else {\n                // Regular texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n                }\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n","import { Texture } from './Texture.js'\n\nexport class RenderTarget {\n    constructor(\n        gl,\n        {\n            width = gl.canvas.width,\n            height = gl.canvas.height,\n            target = gl.FRAMEBUFFER,\n            color = 1, // number of color attachments\n            depth = true,\n            stencil = false,\n            depthTexture = false,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            minFilter = gl.LINEAR,\n            magFilter = minFilter,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            unpackAlignment,\n            premultiplyAlpha,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.buffer = this.gl.createFramebuffer();\n        this.target = target;\n        this.gl.renderer.bindFramebuffer(this);\n\n        this.textures = [];\n        const drawBuffers = [];\n\n        // create and attach required num of color textures\n        for (let i = 0; i < color; i++) {\n            this.textures.push(\n                new Texture(gl, {\n                    width,\n                    height,\n                    wrapS,\n                    wrapT,\n                    wrapR,\n                    minFilter,\n                    magFilter,\n                    type,\n                    format,\n                    internalFormat,\n                    unpackAlignment,\n                    premultiplyAlpha,\n                    flipY: false,\n                    generateMipmaps: false,\n                })\n            );\n            this.textures[i].update();\n            this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0 /* level */);\n            drawBuffers.push(this.gl.COLOR_ATTACHMENT0 + i);\n        }\n\n        // For multi-render targets shader access\n        if (drawBuffers.length > 1) this.gl.renderer.drawBuffers(drawBuffers);\n\n        // alias for majority of use cases\n        this.texture = this.textures[0];\n\n        // note depth textures break stencil - so can't use together\n        if (depthTexture && (this.gl.renderer.isWebgl2 || this.gl.renderer.getExtension('WEBGL_depth_texture'))) {\n            this.depthTexture = new Texture(gl, {\n                width,\n                height,\n                minFilter: this.gl.NEAREST,\n                magFilter: this.gl.NEAREST,\n                format: this.stencil ? this.gl.DEPTH_STENCIL : this.gl.DEPTH_COMPONENT,\n                internalFormat: gl.renderer.isWebgl2 ? (this.stencil ? this.gl.DEPTH24_STENCIL8 : this.gl.DEPTH_COMPONENT16) : this.gl.DEPTH_COMPONENT,\n                type: this.stencil ? this.gl.UNSIGNED_INT_24_8 : this.gl.UNSIGNED_INT,\n            });\n            this.depthTexture.update();\n            this.gl.framebufferTexture2D(this.target, this.stencil ? this.gl.DEPTH_STENCIL_ATTACHMENT : this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0 /* level */);\n        } else {\n            // Render buffers\n            if (depth && !stencil) {\n                this.depthBuffer = this.gl.createRenderbuffer();\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n                this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer);\n            }\n\n            if (stencil && !depth) {\n                this.stencilBuffer = this.gl.createRenderbuffer();\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, width, height);\n                this.gl.framebufferRenderbuffer(this.target, this.gl.STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.stencilBuffer);\n            }\n\n            if (depth && stencil) {\n                this.depthStencilBuffer = this.gl.createRenderbuffer();\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, width, height);\n                this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.depthStencilBuffer);\n            }\n        }\n\n        this.gl.renderer.bindFramebuffer({ target: this.target });\n    }\n\n    setSize(width, height) {\n        if (this.width === width && this.height === height) return;\n\n        this.width = width;\n        this.height = height;\n        this.gl.renderer.bindFramebuffer(this);\n\n        for (let i = 0; i < this.textures.length; i++) {\n            this.textures[i].width = width;\n            this.textures[i].height = height;\n            this.textures[i].needsUpdate = true;\n            this.textures[i].update();\n            this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + i, this.gl.TEXTURE_2D, this.textures[i].texture, 0 /* level */);\n        }\n\n        if (this.depthTexture) {\n            this.depthTexture.width = width;\n            this.depthTexture.height = height;\n            this.depthTexture.needsUpdate = true;\n            this.depthTexture.update();\n            this.gl.framebufferTexture2D(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0 /* level */);\n        } else {\n            if (this.depthBuffer) {\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);\n            }\n\n            if (this.stencilBuffer) {\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, width, height);\n            }\n\n            if (this.depthStencilBuffer) {\n                this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer);\n                this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, width, height);\n            }\n        }\n\n        this.gl.renderer.bindFramebuffer({ target: this.target });\n    }\n}\n","const NAMES = {\n    black: '#000000',\n    white: '#ffffff',\n    red: '#ff0000',\n    green: '#00ff00',\n    blue: '#0000ff',\n    fuchsia: '#ff00ff',\n    cyan: '#00ffff',\n    yellow: '#ffff00',\n    orange: '#ff8000',\n};\n\nexport function hexToRGB(hex) {\n    if (hex.length === 4) hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n    const rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!rgb) console.warn(`Unable to convert hex string ${hex} to rgb values`);\n    return [parseInt(rgb[1], 16) / 255, parseInt(rgb[2], 16) / 255, parseInt(rgb[3], 16) / 255];\n}\n\nexport function numberToRGB(num) {\n    num = parseInt(num);\n    return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];\n}\n\nexport function parseColor(color) {\n    // Empty\n    if (color === undefined) return [0, 0, 0];\n\n    // Decimal\n    if (arguments.length === 3) return arguments;\n\n    // Number\n    if (!isNaN(color)) return numberToRGB(color);\n\n    // Hex\n    if (color[0] === '#') return hexToRGB(color);\n\n    // Names\n    if (NAMES[color.toLowerCase()]) return hexToRGB(NAMES[color.toLowerCase()]);\n\n    console.warn('Color format not recognised');\n    return [0, 0, 0];\n}\n","import * as ColorFunc from './functions/ColorFunc.js';\n\n// Color stored as an array of RGB decimal values (between 0 > 1)\n// Constructor and set method accept following formats:\n// new Color() - Empty (defaults to black)\n// new Color([0.2, 0.4, 1.0]) - Decimal Array (or another Color instance)\n// new Color(0.7, 0.0, 0.1) - Decimal RGB values\n// new Color('#ff0000') - Hex string\n// new Color('#ccc') - Short-hand Hex string\n// new Color(0x4f27e8) - Number\n// new Color('red') - Color name string (short list in ColorFunc.js)\n\nexport class Color extends Array {\n    constructor(color) {\n        if (Array.isArray(color)) return super(...color);\n        return super(...ColorFunc.parseColor(...arguments));\n    }\n\n    get r() {\n        return this[0];\n    }\n\n    get g() {\n        return this[1];\n    }\n\n    get b() {\n        return this[2];\n    }\n\n    set r(v) {\n        this[0] = v;\n    }\n\n    set g(v) {\n        this[1] = v;\n    }\n\n    set b(v) {\n        this[2] = v;\n    }\n\n    set(color) {\n        if (Array.isArray(color)) return this.copy(color);\n        return this.copy(ColorFunc.parseColor(...arguments));\n    }\n\n    copy(v) {\n        this[0] = v[0];\n        this[1] = v[1];\n        this[2] = v[2];\n        return this;\n    }\n}\n","const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    var x = a[0],\n        y = a[1];\n    return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x * x + y * y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product returns a scalar\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} cross product of a and b\n */\nexport function cross(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n}\n\n/**\n * Performs a frame rate independant, linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec2} out\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0];\n    let y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n","import * as Vec2Func from './functions/Vec2Func.js';\n\nexport class Vec2 extends Array {\n    constructor(x = 0, y = x) {\n        super(x, y);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set(x, y = x) {\n        if (x.length) return this.copy(x);\n        Vec2Func.set(this, x, y);\n        return this;\n    }\n\n    copy(v) {\n        Vec2Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec2Func.add(this, va, vb);\n        else Vec2Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec2Func.subtract(this, va, vb);\n        else Vec2Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec2Func.multiply(this, this, v);\n        else Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec2Func.divide(this, this, v);\n        else Vec2Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec2Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec2Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec2Func.distance(this, v);\n        else return Vec2Func.length(this);\n    }\n\n    squaredLen() {\n        return this.squaredDistance();\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec2Func.squaredDistance(this, v);\n        else return Vec2Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec2Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) return Vec2Func.cross(va, vb);\n        return Vec2Func.cross(this, va);\n    }\n\n    scale(v) {\n        Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec2Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec2Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec2Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec2Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec2Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    lerp(v, a) {\n        Vec2Func.lerp(this, this, v, a);\n        return this;\n    }\n\n    smoothLerp(v, decay, dt) {\n        Vec2Func.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n\n    clone() {\n        return new Vec2(this[0], this[1]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        return a;\n    }\n}\n","import * as Vec4Func from './functions/Vec4Func.js';\n\nexport class Vec4 extends Array {\n    constructor(x = 0, y = x, z = x, w = x) {\n        super(x, y, z, w);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set w(v) {\n        this[3] = v;\n    }\n\n    set(x, y = x, z = x, w = x) {\n        if (x.length) return this.copy(x);\n        Vec4Func.set(this, x, y, z, w);\n        return this;\n    }\n\n    copy(v) {\n        Vec4Func.copy(this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec4Func.normalize(this, this);\n        return this;\n    }\n\n    multiply(v) {\n        Vec4Func.scale(this, this, v);\n        return this;\n    }\n\n    dot(v) {\n        return Vec4Func.dot(this, v);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\n\nexport class Plane extends Geometry {\n    constructor(gl, { width = 1, height = 1, widthSegments = 1, heightSegments = 1, attributes = {} } = {}) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n\n        // Determine length of arrays\n        const num = (wSegs + 1) * (hSegs + 1);\n        const numIndices = wSegs * hSegs * 6;\n\n        // Generate empty arrays once\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = numIndices > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        Plane.buildPlane(position, normal, uv, index, width, height, 0, wSegs, hSegs);\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n\n    static buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, u = 0, v = 1, w = 2, uDir = 1, vDir = -1, i = 0, ii = 0) {\n        const io = i;\n        const segW = width / wSegs;\n        const segH = height / hSegs;\n\n        for (let iy = 0; iy <= hSegs; iy++) {\n            let y = iy * segH - height / 2;\n            for (let ix = 0; ix <= wSegs; ix++, i++) {\n                let x = ix * segW - width / 2;\n\n                position[i * 3 + u] = x * uDir;\n                position[i * 3 + v] = y * vDir;\n                position[i * 3 + w] = depth / 2;\n\n                normal[i * 3 + u] = 0;\n                normal[i * 3 + v] = 0;\n                normal[i * 3 + w] = depth >= 0 ? 1 : -1;\n\n                uv[i * 2] = ix / wSegs;\n                uv[i * 2 + 1] = 1 - iy / hSegs;\n\n                if (iy === hSegs || ix === wSegs) continue;\n                let a = io + ix + iy * (wSegs + 1);\n                let b = io + ix + (iy + 1) * (wSegs + 1);\n                let c = io + ix + (iy + 1) * (wSegs + 1) + 1;\n                let d = io + ix + iy * (wSegs + 1) + 1;\n\n                index[ii * 6] = a;\n                index[ii * 6 + 1] = b;\n                index[ii * 6 + 2] = d;\n                index[ii * 6 + 3] = b;\n                index[ii * 6 + 4] = c;\n                index[ii * 6 + 5] = d;\n                ii++;\n            }\n        }\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\nimport { Plane } from './Plane.js';\n\nexport class Box extends Geometry {\n    constructor(gl, { width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1, attributes = {} } = {}) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n        const dSegs = depthSegments;\n\n        const num = (wSegs + 1) * (hSegs + 1) * 2 + (wSegs + 1) * (dSegs + 1) * 2 + (hSegs + 1) * (dSegs + 1) * 2;\n        const numIndices = (wSegs * hSegs * 2 + wSegs * dSegs * 2 + hSegs * dSegs * 2) * 6;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let ii = 0;\n\n        // left, right\n        Plane.buildPlane(position, normal, uv, index, depth, height, width, dSegs, hSegs, 2, 1, 0, -1, -1, i, ii);\n        i += (dSegs + 1) * (hSegs + 1);\n        ii += dSegs * hSegs;\n\n        Plane.buildPlane(position, normal, uv, index, depth, height, -width, dSegs, hSegs, 2, 1, 0, 1, -1, i, ii);\n        i += (dSegs + 1) * (hSegs + 1);\n        ii += dSegs * hSegs;\n\n        // top, bottom\n        Plane.buildPlane(position, normal, uv, index, width, depth, height, dSegs, wSegs, 0, 2, 1, 1, 1, i, ii);\n        i += (wSegs + 1) * (dSegs + 1);\n        ii += wSegs * dSegs;\n\n        Plane.buildPlane(position, normal, uv, index, width, depth, -height, dSegs, wSegs, 0, 2, 1, 1, -1, i, ii);\n        i += (wSegs + 1) * (dSegs + 1);\n        ii += wSegs * dSegs;\n\n        // front, back\n        Plane.buildPlane(position, normal, uv, index, width, height, -depth, wSegs, hSegs, 0, 1, 2, -1, -1, i, ii);\n        i += (wSegs + 1) * (hSegs + 1);\n        ii += wSegs * hSegs;\n\n        Plane.buildPlane(position, normal, uv, index, width, height, depth, wSegs, hSegs, 0, 1, 2, 1, -1, i, ii);\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Sphere extends Geometry {\n    constructor(\n        gl,\n        {\n            radius = 0.5,\n            widthSegments = 16,\n            heightSegments = Math.ceil(widthSegments * 0.5),\n            phiStart = 0,\n            phiLength = Math.PI * 2,\n            thetaStart = 0,\n            thetaLength = Math.PI,\n            attributes = {},\n        } = {}\n    ) {\n        const wSegs = widthSegments;\n        const hSegs = heightSegments;\n        const pStart = phiStart;\n        const pLength = phiLength;\n        const tStart = thetaStart;\n        const tLength = thetaLength;\n\n        const num = (wSegs + 1) * (hSegs + 1);\n        const numIndices = wSegs * hSegs * 6;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let iv = 0;\n        let ii = 0;\n        let te = tStart + tLength;\n        const grid = [];\n\n        let n = new Vec3();\n\n        for (let iy = 0; iy <= hSegs; iy++) {\n            let vRow = [];\n            let v = iy / hSegs;\n            for (let ix = 0; ix <= wSegs; ix++, i++) {\n                let u = ix / wSegs;\n                let x = -radius * Math.cos(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n                let y = radius * Math.cos(tStart + v * tLength);\n                let z = radius * Math.sin(pStart + u * pLength) * Math.sin(tStart + v * tLength);\n\n                position[i * 3] = x;\n                position[i * 3 + 1] = y;\n                position[i * 3 + 2] = z;\n\n                n.set(x, y, z).normalize();\n                normal[i * 3] = n.x;\n                normal[i * 3 + 1] = n.y;\n                normal[i * 3 + 2] = n.z;\n\n                uv[i * 2] = u;\n                uv[i * 2 + 1] = 1 - v;\n\n                vRow.push(iv++);\n            }\n\n            grid.push(vRow);\n        }\n\n        for (let iy = 0; iy < hSegs; iy++) {\n            for (let ix = 0; ix < wSegs; ix++) {\n                let a = grid[iy][ix + 1];\n                let b = grid[iy][ix];\n                let c = grid[iy + 1][ix];\n                let d = grid[iy + 1][ix + 1];\n\n                if (iy !== 0 || tStart > 0) {\n                    index[ii * 3] = a;\n                    index[ii * 3 + 1] = b;\n                    index[ii * 3 + 2] = d;\n                    ii++;\n                }\n                if (iy !== hSegs - 1 || te < Math.PI) {\n                    index[ii * 3] = b;\n                    index[ii * 3 + 1] = c;\n                    index[ii * 3 + 2] = d;\n                    ii++;\n                }\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Cylinder extends Geometry {\n    constructor(\n        gl,\n        {\n            radiusTop = 0.5,\n            radiusBottom = 0.5,\n            height = 1,\n            radialSegments = 8,\n            heightSegments = 1,\n            openEnded = false,\n            thetaStart = 0,\n            thetaLength = Math.PI * 2,\n            attributes = {},\n        } = {}\n    ) {\n        const rSegs = radialSegments;\n        const hSegs = heightSegments;\n        const tStart = thetaStart;\n        const tLength = thetaLength;\n\n        const numCaps = openEnded ? 0 : radiusBottom && radiusTop ? 2 : 1;\n        const num = (rSegs + 1) * (hSegs + 1 + numCaps) + numCaps;\n        const numIndices = rSegs * hSegs * 6 + numCaps * rSegs * 3;\n\n        const position = new Float32Array(num * 3);\n        const normal = new Float32Array(num * 3);\n        const uv = new Float32Array(num * 2);\n        const index = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        let i = 0;\n        let ii = 0;\n        const indexArray = [];\n\n        addHeight();\n        if (!openEnded) {\n            if (radiusTop) addCap(true);\n            if (radiusBottom) addCap(false);\n        }\n\n        function addHeight() {\n            let x, y;\n            const n = new Vec3();\n            const slope = (radiusBottom - radiusTop) / height;\n\n            for (y = 0; y <= hSegs; y++) {\n                const indexRow = [];\n                const v = y / hSegs;\n\n                const r = v * (radiusBottom - radiusTop) + radiusTop;\n                for (x = 0; x <= rSegs; x++) {\n                    const u = x / rSegs;\n                    const theta = u * tLength + tStart;\n                    const sinTheta = Math.sin(theta);\n                    const cosTheta = Math.cos(theta);\n\n                    position.set([r * sinTheta, (0.5 - v) * height, r * cosTheta], i * 3);\n                    n.set(sinTheta, slope, cosTheta).normalize();\n                    normal.set([n.x, n.y, n.z], i * 3);\n                    uv.set([u, 1 - v], i * 2);\n                    indexRow.push(i++);\n                }\n                indexArray.push(indexRow);\n            }\n\n            for (x = 0; x < rSegs; x++) {\n                for (y = 0; y < hSegs; y++) {\n                    const a = indexArray[y][x];\n                    const b = indexArray[y + 1][x];\n                    const c = indexArray[y + 1][x + 1];\n                    const d = indexArray[y][x + 1];\n\n                    index.set([a, b, d, b, c, d], ii * 3);\n                    ii += 2;\n                }\n            }\n        }\n\n        function addCap(isTop) {\n            let x;\n            const r = isTop === true ? radiusTop : radiusBottom;\n            const sign = isTop === true ? 1 : -1;\n\n            const centerIndex = i;\n            position.set([0, 0.5 * height * sign, 0], i * 3);\n            normal.set([0, sign, 0], i * 3);\n            uv.set([0.5, 0.5], i * 2);\n            i++;\n\n            for (x = 0; x <= rSegs; x++) {\n                const u = x / rSegs;\n                const theta = u * tLength + tStart;\n                const cosTheta = Math.cos(theta);\n                const sinTheta = Math.sin(theta);\n\n                position.set([r * sinTheta, 0.5 * height * sign, r * cosTheta], i * 3);\n                normal.set([0, sign, 0], i * 3);\n                uv.set([cosTheta * 0.5 + 0.5, sinTheta * 0.5 * sign + 0.5], i * 2);\n                i++;\n            }\n\n            for (x = 0; x < rSegs; x++) {\n                const j = centerIndex + x + 1;\n                if (isTop) {\n                    index.set([j, j + 1, centerIndex], ii * 3);\n                } else {\n                    index.set([j + 1, j, centerIndex], ii * 3);\n                }\n                ii++;\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: position },\n            normal: { size: 3, data: normal },\n            uv: { size: 2, data: uv },\n            index: { data: index },\n        });\n\n        super(gl, attributes);\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\n\nexport class Triangle extends Geometry {\n    constructor(gl, { attributes = {} } = {}) {\n        Object.assign(attributes, {\n            position: { size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3]) },\n            uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },\n        });\n\n        super(gl, attributes);\n    }\n}\n","// https://github.com/mrdoob/three.js/blob/master/src/geometries/TorusGeometry.js\n\nimport { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nexport class Torus extends Geometry {\n    constructor(gl, { radius = 0.5, tube = 0.2, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2, attributes = {} } = {}) {\n        const num = (radialSegments + 1) * (tubularSegments + 1);\n        const numIndices = radialSegments * tubularSegments * 6;\n\n        const vertices = new Float32Array(num * 3);\n        const normals = new Float32Array(num * 3);\n        const uvs = new Float32Array(num * 2);\n        const indices = num > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        const center = new Vec3();\n        const vertex = new Vec3();\n        const normal = new Vec3();\n\n        // generate vertices, normals and uvs\n        let idx = 0;\n        for (let j = 0; j <= radialSegments; j++) {\n            for (let i = 0; i <= tubularSegments; i++, idx++) {\n                const u = (i / tubularSegments) * arc;\n                const v = (j / radialSegments) * Math.PI * 2;\n\n                // vertex\n                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n                vertex.z = tube * Math.sin(v);\n\n                vertices.set([vertex.x, vertex.y, vertex.z], idx * 3);\n\n                // normal\n                center.x = radius * Math.cos(u);\n                center.y = radius * Math.sin(u);\n                normal.sub(vertex, center).normalize();\n\n                normals.set([normal.x, normal.y, normal.z], idx * 3);\n\n                // uv\n                uvs.set([i / tubularSegments, j / radialSegments], idx * 2);\n            }\n        }\n\n        // generate indices\n        idx = 0;\n        for (let j = 1; j <= radialSegments; j++) {\n            for (let i = 1; i <= tubularSegments; i++, idx++) {\n                // indices\n                const a = (tubularSegments + 1) * j + i - 1;\n                const b = (tubularSegments + 1) * (j - 1) + i - 1;\n                const c = (tubularSegments + 1) * (j - 1) + i;\n                const d = (tubularSegments + 1) * j + i;\n\n                // faces\n                indices.set([a, b, d, b, c, d], idx * 6);\n            }\n        }\n\n        Object.assign(attributes, {\n            position: { size: 3, data: vertices },\n            normal: { size: 3, data: normals },\n            uv: { size: 2, data: uvs },\n            index: { data: indices },\n        });\n\n        super(gl, attributes);\n    }\n}\n","// Based from ThreeJS' OrbitControls class, rewritten using es6 with some additions and subtractions.\n// TODO: abstract event handlers so can be fed from other sources\n// TODO: make scroll zoom more accurate than just >/< zero\n// TODO: be able to pass in new camera position\n\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\nconst STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, DOLLY_PAN: 3 };\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\n\nexport function Orbit(\n    object,\n    {\n        element = document,\n        enabled = true,\n        target = new Vec3(),\n        ease = 0.25,\n        inertia = 0.85,\n        enableRotate = true,\n        rotateSpeed = 0.1,\n        autoRotate = false,\n        autoRotateSpeed = 1.0,\n        enableZoom = true,\n        zoomSpeed = 1,\n        zoomStyle = 'dolly',\n        enablePan = true,\n        panSpeed = 0.1,\n        minPolarAngle = 0,\n        maxPolarAngle = Math.PI,\n        minAzimuthAngle = -Infinity,\n        maxAzimuthAngle = Infinity,\n        minDistance = 0,\n        maxDistance = Infinity,\n    } = {}\n) {\n    this.enabled = enabled;\n    this.target = target;\n    this.zoomStyle = zoomStyle;\n\n    // Catch attempts to disable - set to 1 so has no effect\n    ease = ease || 1;\n    inertia = inertia || 0;\n\n    this.minDistance = minDistance;\n    this.maxDistance = maxDistance;\n\n    // current position in sphericalTarget coordinates\n    const sphericalDelta = { radius: 1, phi: 0, theta: 0 };\n    const sphericalTarget = { radius: 1, phi: 0, theta: 0 };\n    const spherical = { radius: 1, phi: 0, theta: 0 };\n    const panDelta = new Vec3();\n\n    // Grab initial position values\n    const offset = new Vec3();\n    offset.copy(object.position).sub(this.target);\n    spherical.radius = sphericalTarget.radius = offset.distance();\n    spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n    spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n\n    this.offset = offset;\n\n    this.update = () => {\n        if (autoRotate) {\n            handleAutoRotate();\n        }\n\n        // apply delta\n        sphericalTarget.radius *= sphericalDelta.radius;\n        sphericalTarget.theta += sphericalDelta.theta;\n        sphericalTarget.phi += sphericalDelta.phi;\n\n        // apply boundaries\n        sphericalTarget.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sphericalTarget.theta));\n        sphericalTarget.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, sphericalTarget.phi));\n        sphericalTarget.radius = Math.max(this.minDistance, Math.min(this.maxDistance, sphericalTarget.radius));\n\n        // ease values\n        spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n        spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n        spherical.radius += (sphericalTarget.radius - spherical.radius) * ease;\n\n        // apply pan to target. As offset is relative to target, it also shifts\n        this.target.add(panDelta);\n\n        // apply rotation to offset\n        let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n        offset.x = sinPhiRadius * Math.sin(spherical.theta);\n        offset.y = spherical.radius * Math.cos(spherical.phi);\n        offset.z = sinPhiRadius * Math.cos(spherical.theta);\n\n        // Apply updated values to object\n        object.position.copy(this.target).add(offset);\n        object.lookAt(this.target);\n\n        // Apply inertia to values\n        sphericalDelta.theta *= inertia;\n        sphericalDelta.phi *= inertia;\n        panDelta.multiply(inertia);\n\n        // Reset scale every frame to avoid applying scale multiple times\n        sphericalDelta.radius = 1;\n    };\n\n    // Updates internals with new position\n    this.forcePosition = () => {\n        offset.copy(object.position).sub(this.target);\n        spherical.radius = sphericalTarget.radius = offset.distance();\n        spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n        spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n        object.lookAt(this.target);\n    };\n\n    // Everything below here just updates panDelta and sphericalDelta\n    // Using those two objects' values, the orbit is calculated\n\n    const rotateStart = new Vec2();\n    const panStart = new Vec2();\n    const dollyStart = new Vec2();\n\n    let state = STATE.NONE;\n    this.mouseButtons = { ORBIT: 0, ZOOM: 1, PAN: 2 };\n\n    function getZoomScale() {\n        return Math.pow(0.95, zoomSpeed);\n    }\n\n    function panLeft(distance, m) {\n        tempVec3.set(m[0], m[1], m[2]);\n        tempVec3.multiply(-distance);\n        panDelta.add(tempVec3);\n    }\n\n    function panUp(distance, m) {\n        tempVec3.set(m[4], m[5], m[6]);\n        tempVec3.multiply(distance);\n        panDelta.add(tempVec3);\n    }\n\n    const pan = (deltaX, deltaY) => {\n        let el = element === document ? document.body : element;\n        tempVec3.copy(object.position).sub(this.target);\n        let targetDistance = tempVec3.distance();\n        targetDistance *= Math.tan((((object.fov || 45) / 2) * Math.PI) / 180.0);\n        panLeft((2 * deltaX * targetDistance) / el.clientHeight, object.matrix);\n        panUp((2 * deltaY * targetDistance) / el.clientHeight, object.matrix);\n    };\n\n    const dolly = (dollyScale) => {\n        if (this.zoomStyle === 'dolly') sphericalDelta.radius /= dollyScale;\n        else {\n            object.fov /= dollyScale;\n            if (object.type === 'orthographic') object.orthographic();\n            else object.perspective();\n        }\n    };\n\n    function handleAutoRotate() {\n        const angle = ((2 * Math.PI) / 60 / 60) * autoRotateSpeed;\n        sphericalDelta.theta -= angle;\n    }\n\n    function handleMoveRotate(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, rotateStart).multiply(rotateSpeed);\n        let el = element === document ? document.body : element;\n        sphericalDelta.theta -= (2 * Math.PI * tempVec2b.x) / el.clientHeight;\n        sphericalDelta.phi -= (2 * Math.PI * tempVec2b.y) / el.clientHeight;\n        rotateStart.copy(tempVec2a);\n    }\n\n    function handleMouseMoveDolly(e) {\n        tempVec2a.set(e.clientX, e.clientY);\n        tempVec2b.sub(tempVec2a, dollyStart);\n        if (tempVec2b.y > 0) {\n            dolly(getZoomScale());\n        } else if (tempVec2b.y < 0) {\n            dolly(1 / getZoomScale());\n        }\n        dollyStart.copy(tempVec2a);\n    }\n\n    function handleMovePan(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, panStart).multiply(panSpeed);\n        pan(tempVec2b.x, tempVec2b.y);\n        panStart.copy(tempVec2a);\n    }\n\n    function handleTouchStartDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            panStart.set(x, y);\n        }\n    }\n\n    function handleTouchMoveDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            tempVec2a.set(0, distance);\n            tempVec2b.set(0, Math.pow(tempVec2a.y / dollyStart.y, zoomSpeed));\n            dolly(tempVec2b.y);\n            dollyStart.copy(tempVec2a);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            handleMovePan(x, y);\n        }\n    }\n\n    const onMouseDown = (e) => {\n        if (!this.enabled) return;\n\n        switch (e.button) {\n            case this.mouseButtons.ORBIT:\n                if (enableRotate === false) return;\n                rotateStart.set(e.clientX, e.clientY);\n                state = STATE.ROTATE;\n                break;\n            case this.mouseButtons.ZOOM:\n                if (enableZoom === false) return;\n                dollyStart.set(e.clientX, e.clientY);\n                state = STATE.DOLLY;\n                break;\n            case this.mouseButtons.PAN:\n                if (enablePan === false) return;\n                panStart.set(e.clientX, e.clientY);\n                state = STATE.PAN;\n                break;\n        }\n\n        if (state !== STATE.NONE) {\n            window.addEventListener('mousemove', onMouseMove, false);\n            window.addEventListener('mouseup', onMouseUp, false);\n        }\n    };\n\n    const onMouseMove = (e) => {\n        if (!this.enabled) return;\n\n        switch (state) {\n            case STATE.ROTATE:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.clientX, e.clientY);\n                break;\n            case STATE.DOLLY:\n                if (enableZoom === false) return;\n                handleMouseMoveDolly(e);\n                break;\n            case STATE.PAN:\n                if (enablePan === false) return;\n                handleMovePan(e.clientX, e.clientY);\n                break;\n        }\n    };\n\n    const onMouseUp = () => {\n        window.removeEventListener('mousemove', onMouseMove, false);\n        window.removeEventListener('mouseup', onMouseUp, false);\n        state = STATE.NONE;\n    };\n\n    const onMouseWheel = (e) => {\n        if (!this.enabled || !enableZoom || (state !== STATE.NONE && state !== STATE.ROTATE)) return;\n        e.stopPropagation();\n        e.preventDefault();\n\n        if (e.deltaY < 0) {\n            dolly(1 / getZoomScale());\n        } else if (e.deltaY > 0) {\n            dolly(getZoomScale());\n        }\n    };\n\n    const onTouchStart = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);\n                state = STATE.ROTATE;\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchStartDollyPan(e);\n                state = STATE.DOLLY_PAN;\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchMove = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n        e.stopPropagation();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.touches[0].pageX, e.touches[0].pageY);\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchMoveDollyPan(e);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchEnd = () => {\n        if (!this.enabled) return;\n        state = STATE.NONE;\n    };\n\n    const onContextMenu = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n    };\n\n    function addHandlers() {\n        element.addEventListener('contextmenu', onContextMenu, false);\n        element.addEventListener('mousedown', onMouseDown, false);\n        element.addEventListener('wheel', onMouseWheel, { passive: false });\n        element.addEventListener('touchstart', onTouchStart, { passive: false });\n        element.addEventListener('touchend', onTouchEnd, false);\n        element.addEventListener('touchmove', onTouchMove, { passive: false });\n    }\n\n    this.remove = function () {\n        element.removeEventListener('contextmenu', onContextMenu);\n        element.removeEventListener('mousedown', onMouseDown);\n        element.removeEventListener('wheel', onMouseWheel);\n        element.removeEventListener('touchstart', onTouchStart);\n        element.removeEventListener('touchend', onTouchEnd);\n        element.removeEventListener('touchmove', onTouchMove);\n        window.removeEventListener('mousemove', onMouseMove);\n        window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    addHandlers();\n}\n","// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\nconst tempVec2c = /* @__PURE__ */ new Vec2();\n\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\nconst tempVec3c = /* @__PURE__ */ new Vec3();\nconst tempVec3d = /* @__PURE__ */ new Vec3();\nconst tempVec3e = /* @__PURE__ */ new Vec3();\nconst tempVec3f = /* @__PURE__ */ new Vec3();\nconst tempVec3g = /* @__PURE__ */ new Vec3();\nconst tempVec3h = /* @__PURE__ */ new Vec3();\nconst tempVec3i = /* @__PURE__ */ new Vec3();\nconst tempVec3j = /* @__PURE__ */ new Vec3();\nconst tempVec3k = /* @__PURE__ */ new Vec3();\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Raycast {\n    constructor() {\n        this.origin = new Vec3();\n        this.direction = new Vec3();\n    }\n\n    // Set ray from mouse unprojection\n    castMouse(camera, mouse = [0, 0]) {\n        if (camera.type === 'orthographic') {\n            // Set origin\n            // Since camera is orthographic, origin is not the camera position\n            const { left, right, bottom, top, zoom } = camera;\n            const x = left / zoom + ((right - left) / zoom) * (mouse[0] * 0.5 + 0.5);\n            const y = bottom / zoom + ((top - bottom) / zoom) * (mouse[1] * 0.5 + 0.5);\n            this.origin.set(x, y, 0);\n            this.origin.applyMatrix4(camera.worldMatrix);\n\n            // Set direction\n            // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n            this.direction.x = -camera.worldMatrix[8];\n            this.direction.y = -camera.worldMatrix[9];\n            this.direction.z = -camera.worldMatrix[10];\n        } else {\n            // Set origin\n            camera.worldMatrix.getTranslation(this.origin);\n\n            // Set direction\n            this.direction.set(mouse[0], mouse[1], 0.5);\n            camera.unproject(this.direction);\n            this.direction.sub(this.origin).normalize();\n        }\n    }\n\n    intersectBounds(meshes, { maxDistance, output = [] } = {}) {\n        if (!Array.isArray(meshes)) meshes = [meshes];\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n\n        const hits = output;\n        hits.length = 0;\n\n        meshes.forEach((mesh) => {\n            // Create bounds\n            if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n            const bounds = mesh.geometry.bounds;\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            // Break out early if bounds too far away from origin\n            if (maxDistance) {\n                if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n            }\n\n            let localDistance = 0;\n\n            // Check origin isn't inside bounds before testing intersection\n            if (mesh.geometry.raycast === 'sphere') {\n                if (origin.distance(bounds.center) > bounds.radius) {\n                    localDistance = this.intersectSphere(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            } else {\n                if (\n                    origin.x < bounds.min.x ||\n                    origin.x > bounds.max.x ||\n                    origin.y < bounds.min.y ||\n                    origin.y > bounds.max.y ||\n                    origin.z < bounds.min.z ||\n                    origin.z > bounds.max.z\n                ) {\n                    localDistance = this.intersectBox(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            }\n\n            if (maxDistance && localDistance > localMaxDistance) return;\n\n            // Create object on mesh to avoid generating lots of objects\n            if (!mesh.hit) mesh.hit = { localPoint: new Vec3(), point: new Vec3() };\n\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            hits.push(mesh);\n        });\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectMeshes(meshes, { cullFace = true, maxDistance, includeUV = true, includeNormal = true, output = [] } = {}) {\n        // Test bounds first before testing geometry\n        const hits = this.intersectBounds(meshes, { maxDistance, output });\n        if (!hits.length) return hits;\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n        const a = tempVec3c;\n        const b = tempVec3d;\n        const c = tempVec3e;\n        const closestFaceNormal = tempVec3f;\n        const faceNormal = tempVec3g;\n        const barycoord = tempVec3h;\n        const uvA = tempVec2a;\n        const uvB = tempVec2b;\n        const uvC = tempVec2c;\n\n        for (let i = hits.length - 1; i >= 0; i--) {\n            const mesh = hits[i];\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            let localDistance = 0;\n            let closestA, closestB, closestC;\n\n            const geometry = mesh.geometry;\n            const attributes = geometry.attributes;\n            const index = attributes.index;\n            const position = attributes.position;\n\n            const start = Math.max(0, geometry.drawRange.start);\n            const end = Math.min(index ? index.count : position.count, geometry.drawRange.start + geometry.drawRange.count);\n            // Data loaded shouldn't haave stride, only buffers\n            // const stride = position.stride ? position.stride / position.data.BYTES_PER_ELEMENT : position.size;\n            const stride = position.size;\n\n            for (let j = start; j < end; j += 3) {\n                // Position attribute indices for each triangle\n                const ai = index ? index.data[j] : j;\n                const bi = index ? index.data[j + 1] : j + 1;\n                const ci = index ? index.data[j + 2] : j + 2;\n\n                a.fromArray(position.data, ai * stride);\n                b.fromArray(position.data, bi * stride);\n                c.fromArray(position.data, ci * stride);\n\n                const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n                if (!distance) continue;\n\n                // Too far away\n                if (maxDistance && distance > localMaxDistance) continue;\n\n                if (!localDistance || distance < localDistance) {\n                    localDistance = distance;\n                    closestA = ai;\n                    closestB = bi;\n                    closestC = ci;\n                    closestFaceNormal.copy(faceNormal);\n                }\n            }\n\n            if (!localDistance) hits.splice(i, 1);\n\n            // Update hit values from bounds-test\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            // Add unique hit objects on mesh to avoid generating lots of objects\n            if (!mesh.hit.faceNormal) {\n                mesh.hit.localFaceNormal = new Vec3();\n                mesh.hit.faceNormal = new Vec3();\n                mesh.hit.uv = new Vec2();\n                mesh.hit.localNormal = new Vec3();\n                mesh.hit.normal = new Vec3();\n            }\n\n            // Add face normal data which is already computed\n            mesh.hit.localFaceNormal.copy(closestFaceNormal);\n            mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n            // Optional data, opt out to optimise a bit if necessary\n            if (includeUV || includeNormal) {\n                // Calculate barycoords to find uv values at hit point\n                a.fromArray(position.data, closestA * 3);\n                b.fromArray(position.data, closestB * 3);\n                c.fromArray(position.data, closestC * 3);\n                this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n            }\n\n            if (includeUV && attributes.uv) {\n                uvA.fromArray(attributes.uv.data, closestA * 2);\n                uvB.fromArray(attributes.uv.data, closestB * 2);\n                uvC.fromArray(attributes.uv.data, closestC * 2);\n                mesh.hit.uv.set(\n                    uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z,\n                    uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z\n                );\n            }\n\n            if (includeNormal && attributes.normal) {\n                a.fromArray(attributes.normal.data, closestA * 3);\n                b.fromArray(attributes.normal.data, closestB * 3);\n                c.fromArray(attributes.normal.data, closestC * 3);\n                mesh.hit.localNormal.set(\n                    a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z,\n                    a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z,\n                    a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z\n                );\n\n                mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n            }\n        }\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectPlane(plane, origin = this.origin, direction = this.direction) {\n        const xminp = tempVec3a;\n        xminp.sub(plane.origin, origin);\n\n        const a = xminp.dot(plane.normal);\n        const b = direction.dot(plane.normal);\n        // Assuming we don't want to count a ray parallel to the plane as intersecting\n        if (b == 0) return 0;\n        const delta = a / b;\n        if (delta <= 0) return 0;\n        return origin.add(direction.scale(delta));\n    }\n\n    intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n        const ray = tempVec3c;\n        ray.sub(sphere.center, origin);\n        const tca = ray.dot(direction);\n        const d2 = ray.dot(ray) - tca * tca;\n        const radius2 = sphere.radius * sphere.radius;\n        if (d2 > radius2) return 0;\n        const thc = Math.sqrt(radius2 - d2);\n        const t0 = tca - thc;\n        const t1 = tca + thc;\n        if (t0 < 0 && t1 < 0) return 0;\n        if (t0 < 0) return t1;\n        return t0;\n    }\n\n    // Ray AABB - Ray Axis aligned bounding box testing\n    intersectBox(box, origin = this.origin, direction = this.direction) {\n        let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n        const invdirx = 1 / direction.x;\n        const invdiry = 1 / direction.y;\n        const invdirz = 1 / direction.z;\n        const min = box.min;\n        const max = box.max;\n        tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n        tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n        tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n        tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n        if (tmin > tYmax || tYmin > tmax) return 0;\n        if (tYmin > tmin) tmin = tYmin;\n        if (tYmax < tmax) tmax = tYmax;\n        tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n        tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n        if (tmin > tZmax || tZmin > tmax) return 0;\n        if (tZmin > tmin) tmin = tZmin;\n        if (tZmax < tmax) tmax = tZmax;\n        if (tmax < 0) return 0;\n        return tmin >= 0 ? tmin : tmax;\n    }\n\n    intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n        // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n        // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n        const edge1 = tempVec3h;\n        const edge2 = tempVec3i;\n        const diff = tempVec3j;\n        edge1.sub(b, a);\n        edge2.sub(c, a);\n        normal.cross(edge1, edge2);\n        let DdN = direction.dot(normal);\n        if (!DdN) return 0;\n        let sign;\n        if (DdN > 0) {\n            if (backfaceCulling) return 0;\n            sign = 1;\n        } else {\n            sign = -1;\n            DdN = -DdN;\n        }\n        diff.sub(origin, a);\n        let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n        if (DdQxE2 < 0) return 0;\n        let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n        if (DdE1xQ < 0) return 0;\n        if (DdQxE2 + DdE1xQ > DdN) return 0;\n        let QdN = -sign * diff.dot(normal);\n        if (QdN < 0) return 0;\n        return QdN / DdN;\n    }\n\n    getBarycoord(point, a, b, c, target = tempVec3h) {\n        // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n        // static/instance method to calculate barycentric coordinates\n        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n        const v0 = tempVec3i;\n        const v1 = tempVec3j;\n        const v2 = tempVec3k;\n        v0.sub(c, a);\n        v1.sub(b, a);\n        v2.sub(point, a);\n        const dot00 = v0.dot(v0);\n        const dot01 = v0.dot(v1);\n        const dot02 = v0.dot(v2);\n        const dot11 = v1.dot(v1);\n        const dot12 = v1.dot(v2);\n        const denom = dot00 * dot11 - dot01 * dot01;\n        if (denom === 0) return target.set(-2, -1, -1);\n        const invDenom = 1 / denom;\n        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        return target.set(1 - u - v, v, u);\n    }\n}\n","import { Vec3 } from '../math/Vec3.js';\n\nconst CATMULLROM = 'catmullrom';\nconst CUBICBEZIER = 'cubicbezier';\nconst QUADRATICBEZIER = 'quadraticbezier';\n\n// temp\nconst _a0 = /* @__PURE__ */ new Vec3(),\n    _a1 = /* @__PURE__ */ new Vec3(),\n    _a2 = /* @__PURE__ */ new Vec3(),\n    _a3 = /* @__PURE__ */ new Vec3();\n\n/**\n * Get the control points of cubic bezier curve.\n * @param {*} i\n * @param {*} a\n * @param {*} b\n */\nfunction getCtrlPoint(points, i, a = 0.168, b = 0.168) {\n    if (i < 1) {\n        _a0.sub(points[1], points[0]).scale(a).add(points[0]);\n    } else {\n        _a0.sub(points[i + 1], points[i - 1])\n            .scale(a)\n            .add(points[i]);\n    }\n    if (i > points.length - 3) {\n        const last = points.length - 1;\n        _a1.sub(points[last - 1], points[last])\n            .scale(b)\n            .add(points[last]);\n    } else {\n        _a1.sub(points[i], points[i + 2])\n            .scale(b)\n            .add(points[i + 1]);\n    }\n    return [_a0.clone(), _a1.clone()];\n}\n\nfunction getQuadraticBezierPoint(t, p0, c0, p1) {\n    const k = 1 - t;\n    _a0.copy(p0).scale(k ** 2);\n    _a1.copy(c0).scale(2 * k * t);\n    _a2.copy(p1).scale(t ** 2);\n    const ret = new Vec3();\n    ret.add(_a0, _a1).add(_a2);\n    return ret;\n}\n\nfunction getCubicBezierPoint(t, p0, c0, c1, p1) {\n    const k = 1 - t;\n    _a0.copy(p0).scale(k ** 3);\n    _a1.copy(c0).scale(3 * k ** 2 * t);\n    _a2.copy(c1).scale(3 * k * t ** 2);\n    _a3.copy(p1).scale(t ** 3);\n    const ret = new Vec3();\n    ret.add(_a0, _a1).add(_a2).add(_a3);\n    return ret;\n}\n\nexport class Curve {\n    constructor({ points = [new Vec3(0, 0, 0), new Vec3(0, 1, 0), new Vec3(1, 1, 0), new Vec3(1, 0, 0)], divisions = 12, type = CATMULLROM } = {}) {\n        this.points = points;\n        this.divisions = divisions;\n        this.type = type;\n    }\n\n    _getQuadraticBezierPoints(divisions = this.divisions) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count < 3) {\n            console.warn('Not enough points provided.');\n            return [];\n        }\n\n        const p0 = this.points[0];\n        let c0 = this.points[1],\n            p1 = this.points[2];\n\n        for (let i = 0; i <= divisions; i++) {\n            const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n            points.push(p);\n        }\n\n        let offset = 3;\n        while (count - offset > 0) {\n            p0.copy(p1);\n            c0 = p1.scale(2).sub(c0);\n            p1 = this.points[offset];\n            for (let i = 1; i <= divisions; i++) {\n                const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n                points.push(p);\n            }\n            offset++;\n        }\n\n        return points;\n    }\n\n    _getCubicBezierPoints(divisions = this.divisions) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count < 4) {\n            console.warn('Not enough points provided.');\n            return [];\n        }\n\n        let p0 = this.points[0],\n            c0 = this.points[1],\n            c1 = this.points[2],\n            p1 = this.points[3];\n\n        for (let i = 0; i <= divisions; i++) {\n            const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n            points.push(p);\n        }\n\n        let offset = 4;\n        while (count - offset > 1) {\n            p0.copy(p1);\n            c0 = p1.scale(2).sub(c1);\n            c1 = this.points[offset];\n            p1 = this.points[offset + 1];\n            for (let i = 1; i <= divisions; i++) {\n                const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n                points.push(p);\n            }\n            offset += 2;\n        }\n\n        return points;\n    }\n\n    _getCatmullRomPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count <= 2) {\n            return this.points;\n        }\n\n        let p0;\n        this.points.forEach((p, i) => {\n            if (i === 0) {\n                p0 = p;\n            } else {\n                const [c0, c1] = getCtrlPoint(this.points, i - 1, a, b);\n                const c = new Curve({\n                    points: [p0, c0, c1, p],\n                    type: CUBICBEZIER,\n                });\n                points.pop();\n                points.push(...c.getPoints(divisions));\n                p0 = p;\n            }\n        });\n\n        return points;\n    }\n\n    getPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n        const type = this.type;\n\n        if (type === QUADRATICBEZIER) {\n            return this._getQuadraticBezierPoints(divisions);\n        }\n\n        if (type === CUBICBEZIER) {\n            return this._getCubicBezierPoints(divisions);\n        }\n\n        if (type === CATMULLROM) {\n            return this._getCatmullRomPoints(divisions, a, b);\n        }\n\n        return this.points;\n    }\n}\n\nCurve.CATMULLROM = CATMULLROM;\nCurve.CUBICBEZIER = CUBICBEZIER;\nCurve.QUADRATICBEZIER = QUADRATICBEZIER;\n","/**\n * Abstract base class for path segments.\n * This class contains common methods for all segments types.\n */\nexport default class BaseSegment {\n    constructor() {\n        this._len = -1;\n        this.tiltStart = 0;\n        this.tiltEnd = 0;\n    }\n\n    /**\n     * Get segment length.\n     * @returns {number} segment length\n     */\n    getLength() {\n        if (this._len < 0) {\n            this.updateLength();\n        }\n\n        return this._len;\n    }\n\n    /**\n     * Get tilt angle at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @returns {number} Tilt angle at t\n     */\n    getTiltAt(t) {\n        return this.tiltStart * (1 - t) * this.tiltEnd * t;\n    }\n\n    /**\n     * Creates a clone of this instance\n     * @returns {BaseSegment} cloned instance\n     */\n    clone() {\n        return new this.constructor().copy(this);\n    }\n\n    /**\n     * Copies another segment object to this instance.\n     * @param {BaseSegment} source reference object\n     * @returns {BaseSegment} copy of source object\n     */\n    copy(source) {\n        this._len = source._len;\n        this.tiltStart = source.tiltStart;\n        this.tiltEnd = source.tiltEnd;\n        return this;\n    }\n}\n","// from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L26\n// Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\nexport const T_VALUES = [\n    -0.0640568928626056260850430826247450385909, 0.0640568928626056260850430826247450385909, -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404, -0.3150426796961633743867932913198102407864, 0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524, 0.4337935076260451384870842319133497124524, -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107, -0.6480936519369755692524957869107476266696, 0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232, 0.7401241915785543642438281030999784255232, -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761, -0.8864155270044010342131543419821967550873, 0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548, 0.9382745520027327585236490017087214496548, -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411, -0.9951872199970213601799974097007368118745, 0.9951872199970213601799974097007368118745,\n];\n\n// Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\nexport const C_VALUES = [\n    0.1279381953467521569740561652246953718517, 0.1279381953467521569740561652246953718517, 0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264, 0.121670472927803391204463153476262425607, 0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622, 0.1155056680537256013533444839067835598622, 0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946, 0.0976186521041138882698806644642471544279, 0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185, 0.086190161531953275917185202983742667185, 0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193, 0.0592985849154367807463677585001085845412, 0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593, 0.0442774388174198061686027482113382288593, 0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491, 0.0123412297999871995468056670700372915759, 0.0123412297999871995468056670700372915759,\n];\n\n/**\n * Convert Degree To Radian\n * @param {number} a Angle in Degrees\n * @returns {number} a Angle in Radians\n */\nexport const toRadian = (a) => (a * Math.PI) / 180;\n\n/**\n * Convert Radian To Degree\n * @param {number} a Angle in Radians\n * @returns {number} a Angle in Radian\n */\nexport const toDegrees = (a) => (180 * a) / Math.PI;\n\nexport const clamp = (val, min, max) => Math.max(min, Math.min(val, max));\nexport const lerp = (t, v0, v1) => v0 * (t - 1) + v1 * t;\n\n/**\n * Fills a rotation matrix with the given sine and cosine of the angle around the given axis\n * This function helps to avoid inverse trigonometry\n * @param {Mat4} out mat4 receiving operation result\n * @param {Vec3} axis the axis to rotate around. Should be normalized\n * @param {number} sin sine of rotation angle\n * @param {number} cos cosine of rotation angle\n * @returns {Mat4} out\n */\nexport function mat4fromRotationSinCos(out, axis, sin, cos) {\n    const x = axis[0];\n    const y = axis[1];\n    const z = axis[2];\n    const t = 1 - cos;\n\n    out[0] = x * x * t + cos;\n    out[1] = y * x * t + z * sin;\n    out[2] = z * x * t - y * sin;\n    out[3] = 0;\n    out[4] = x * y * t - z * sin;\n    out[5] = y * y * t + cos;\n    out[6] = z * y * t + x * sin;\n    out[7] = 0;\n    out[8] = x * z * t + y * sin;\n    out[9] = y * z * t - x * sin;\n    out[10] = z * z * t + cos;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Rotates the normal and binormal around its tangent by the given angle.\n *\n * see: https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n * @param {number} angle rotation angle\n * @param {Vec3} norm unit normal vector\n * @param {Vec3} binorm unit binormal vector\n * @param {Vec3} outNorm optional normal output vector. If not present then normal vector changes in place\n * @param {Vec3} outBinorm optional binormal output vector. If not present then binormal vector changes in place\n */\nexport function rotateNormalBinormal(angle, norm, binorm, outNorm = norm, outBinorm = binorm) {\n    const s = Math.sin(angle);\n    const c = Math.cos(angle);\n\n    const nx = c * norm.x + s * binorm.x;\n    const ny = c * norm.y + s * binorm.y;\n    const nz = c * norm.z + s * binorm.z;\n\n    const bx = c * binorm.x - s * norm.x;\n    const by = c * binorm.y - s * norm.y;\n    const bz = c * binorm.z - s * norm.z;\n\n    outNorm.set(nx, ny, nz);\n    outBinorm.set(bx, by, bz);\n}\n","import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { T_VALUES, C_VALUES } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nfunction cubicBezier(t, p0, p1, p2, p3) {\n    const k = 1 - t;\n    // prettier-ignore\n    return (\n        (k * k * k * p0) +\n        (3 * k * k * t * p1) +\n        (3 * k * t * t * p2) +\n        (t * t * t * p3)\n    );\n}\n\nfunction cubicBezierDeriv(t, p0, p1, p2, p3) {\n    const k = 1 - t;\n    // prettier-ignore\n    return (\n        (3 * k * k * (p1 - p0)) +\n        (6 * k * t * (p2 - p1)) +\n        (3 * t * t * (p3 - p2))\n    );\n}\n\nexport default class CubicBezierSegment extends BaseSegment {\n    constructor(p0, p1, p2, p3, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        // from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L265\n        const z = 0.5;\n        const len = T_VALUES.length;\n\n        let sum = 0;\n        for (let i = 0, t; i < len; i++) {\n            t = z * T_VALUES[i] + z;\n            sum += C_VALUES[i] * this.getDerivativeAt(t, tempVec3).len();\n        }\n\n        this._len = z * sum;\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        out.x = cubicBezier(t, this.p0.x, this.p1.x, this.p2.x, this.p3.x);\n        out.y = cubicBezier(t, this.p0.y, this.p1.y, this.p2.y, this.p3.y);\n        out.z = cubicBezier(t, this.p0.z, this.p1.z, this.p2.z, this.p3.z);\n        return out;\n    }\n\n    getDerivativeAt(t, out = new Vec3()) {\n        out.x = cubicBezierDeriv(t, this.p0.x, this.p1.x, this.p2.x, this.p3.x);\n        out.y = cubicBezierDeriv(t, this.p0.y, this.p1.y, this.p2.y, this.p3.y);\n        out.z = cubicBezierDeriv(t, this.p0.z, this.p1.z, this.p2.z, this.p3.z);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return this.getDerivativeAt(t, out).normalize();\n    }\n\n    lastPoint() {\n        return this.p3;\n    }\n}\n","import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { T_VALUES, C_VALUES } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nfunction quadraticBezier(t, p0, p1, p2) {\n    const k = 1 - t;\n    return k * k * p0 + 2 * k * t * p1 + t * t * p2;\n}\n\nfunction quadraticBezierDeriv(t, p0, p1, p2) {\n    const k = 1 - t;\n    return 2 * k * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\nexport default class QuadraticBezierSegment extends BaseSegment {\n    constructor(p0, p1, p2, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        // from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L265\n        const z = 0.5;\n        const len = T_VALUES.length;\n\n        let sum = 0;\n        for (let i = 0, t; i < len; i++) {\n            t = z * T_VALUES[i] + z;\n            sum += C_VALUES[i] * this.getDerivativeAt(t, tempVec3).len();\n        }\n\n        this._len = z * sum;\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        out.x = quadraticBezier(t, this.p0.x, this.p1.x, this.p2.x);\n        out.y = quadraticBezier(t, this.p0.y, this.p1.y, this.p2.y);\n        out.z = quadraticBezier(t, this.p0.z, this.p1.z, this.p2.z);\n        return out;\n    }\n\n    getDerivativeAt(t, out = new Vec3()) {\n        out.x = quadraticBezierDeriv(t, this.p0.x, this.p1.x, this.p2.x);\n        out.y = quadraticBezierDeriv(t, this.p0.y, this.p1.y, this.p2.y);\n        out.z = quadraticBezierDeriv(t, this.p0.z, this.p1.z, this.p2.z);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return this.getDerivativeAt(t, out).normalize();\n    }\n\n    lastPoint() {\n        return this.p2;\n    }\n}\n","import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { lerp as lerp3 } from '../../math/functions/Vec3Func.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nexport default class LineSegment extends BaseSegment {\n    constructor(p0, p1, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        this._len = tempVec3.sub(this.p1, this.p0).len();\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        lerp3(out, this.p0, this.p1, t);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return out.sub(this.p1, this.p0).normalize();\n    }\n\n    lastPoint() {\n        return this.p1;\n    }\n}\n","import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nfunction throwIfNullProperty(property, message) {\n    if (this[property] == null) throw new Error(message);\n}\n\nexport class Path {\n    constructor() {\n        this._segments = [];\n        this._lengthOffsets = null;\n        this._totalLength = -1;\n        this._lastPoint = null;\n        this._lastTilt = 0;\n\n        this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n\n        this.tiltFunction = null;\n    }\n\n    moveTo(p, tilt = 0) {\n        this._totalLength = -1;\n        this._lastPoint = p;\n        this._lastTilt = tilt;\n    }\n\n    bezierCurveTo(cp1, cp2, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    quadraticCurveTo(cp, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    lineTo(p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    addSegment(segment) {\n        this._totalLength = -1;\n        this._lastPoint = segment.lastPoint();\n        this._lastTilt = segment.tiltEnd;\n        this._segments.push(segment);\n        return this;\n    }\n\n    getSegments() {\n        return this._segments;\n    }\n\n    updateLength() {\n        const n = this._segments.length;\n        this._lengthOffsets = new Array(n);\n\n        let offset = 0;\n        for (let i = 0; i < n; i++) {\n            this._lengthOffsets[i] = offset;\n            offset += this._segments[i].getLength();\n        }\n\n        this._totalLength = offset;\n    }\n\n    getLength() {\n        if (this._totalLength < 0) {\n            this.updateLength();\n        }\n\n        return this._totalLength;\n    }\n\n    /**\n     * Finding a path segment at a given absolute length distance\n     * @param {number} len absolute length distance\n     * @returns {[number, number]} [_segment index_, _relative segment distance_]\n     */\n    findSegmentIndexAtLength(len) {\n        const totalLength = this.getLength();\n\n        if (len <= 0) {\n            return [0, 0];\n        }\n\n        if (len >= totalLength) {\n            return [this._segments.length - 1, 1];\n        }\n\n        let start = 0;\n        let end = this._lengthOffsets.length - 1;\n        let index = -1;\n        let mid;\n\n        while (start <= end) {\n            mid = Math.ceil((start + end) / 2);\n\n            if (mid === 0 || mid === this._lengthOffsets.length - 1 || (len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1])) {\n                index = mid;\n                break;\n            } else if (len < this._lengthOffsets[mid]) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        const seg = this._segments[index];\n        const segLen = seg.getLength();\n        const t = (len - this._lengthOffsets[index]) / segLen;\n\n        return [index, t];\n    }\n\n    getPointAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getPointAt(t, out);\n    }\n\n    getPointAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getPointAtLength(t * totalLength, out);\n    }\n\n    getTangentAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTangentAt(t, out);\n    }\n\n    getTangentAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getTangentAtLength(t * totalLength, out);\n    }\n\n    getTiltAtLength(len) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTiltAt(t);\n    }\n\n    getTiltAt(t) {\n        const totalLength = this.getLength();\n        return this.getTiltAtLength(t * totalLength);\n    }\n\n    /**\n     * Get sequence of points using `getPointAt(t)`\n     * @param {number} divisions number of subdivisions\n     * @returns {Vec3[]} array of points\n     */\n    getPoints(divisions = 64) {\n        const points = new Array(divisions + 1);\n        for (let i = 0; i <= divisions; i++) {\n            points[i] = this.getPointAt(i / divisions);\n        }\n        return points;\n    }\n\n    /**\n     * Generates the Frenet Frames.\n     * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n     * @param {number} divisions number of subdivisions\n     * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n     */\n    computeFrenetFrames(divisions = 64, closed = false) {\n        const tangents = new Array(divisions + 1);\n        const tilts = new Array(divisions + 1);\n\n        const tiltFunction = this.tiltFunction ?? ((a) => a);\n\n        // compute the tangent vectors and tilt for each segment on the curve\n        const totalLength = this.getLength();\n        for (let i = 0; i <= divisions; i++) {\n            const [si, st] = this.findSegmentIndexAtLength((totalLength * i) / divisions);\n            const segment = this._segments[si];\n            tangents[i] = segment.getTangentAt(st);\n            tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n        }\n\n        const tx = Math.abs(tangents[0].x);\n        const ty = Math.abs(tangents[0].y);\n        const tz = Math.abs(tangents[0].z);\n\n        const normal = new Vec3();\n        if (tx < ty && tx < tz) {\n            normal.set(1, 0, 0);\n        } else if (ty < tx && ty < tz) {\n            normal.set(0, 1, 0);\n        } else {\n            normal.set(0, 0, 1);\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n        const normals = new Array(divisions + 1);\n        const binormals = new Array(divisions + 1);\n        normals[0] = new Vec3();\n        binormals[0] = new Vec3();\n\n        tempVec3.cross(tangents[0], normal).normalize();\n        normals[0].cross(tangents[0], tempVec3);\n        binormals[0].cross(tangents[0], normals[0]);\n\n        // compute the slowly-varying normal vector for each segment on the curve\n        for (let i = 1; i < tangents.length; i++) {\n            normals[i] = normals[i - 1].clone();\n            binormals[i] = new Vec3();\n\n            tempVec3.cross(tangents[i - 1], tangents[i]);\n            const crossLen = tempVec3.len();\n\n            if (crossLen > Number.EPSILON) {\n                tempVec3.scale(1 / crossLen); // nomalize\n                const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n                const sinTheta = clamp(crossLen, -1, 1);\n\n                mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n                normals[i].applyMatrix4(tempMat4);\n            }\n\n            binormals[i].cross(tangents[i], normals[i]);\n        }\n\n        // add tilt twisting\n        for (let i = 0; i < tilts.length; i++) {\n            rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n        if (closed === true) {\n            const normalLast = normals[normals.length - 1];\n            let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n\n            if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n                step = -step;\n            }\n\n            for (let i = 1; i < normals.length - 1; i++) {\n                const angle = step * i;\n                rotateNormalBinormal(angle, normals[i], binormals[i]);\n                tilts[i] += toDegrees(angle);\n            }\n\n            normals[normals.length - 1] = normals[0].clone();\n            binormals[binormals.length - 1] = binormals[0].clone();\n        }\n\n        return { tangents, normals, binormals, tilts };\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\n// helper variables\nconst vertex = /* @__PURE__ */ new Vec3();\nconst normal = /* @__PURE__ */ new Vec3();\nconst uv = /* @__PURE__ */ new Vec2();\nconst point = /* @__PURE__ */ new Vec3();\n\nexport class Tube extends Geometry {\n    constructor(gl, { path, radius = 1, tubularSegments = 64, radialSegments = 8, closed = false, attributes = {} } = {}) {\n        super(gl, attributes);\n\n        this.path = path;\n        this.radius = radius;\n        this.tubularSegments = tubularSegments;\n        this.radialSegments = radialSegments;\n        this.closed = closed;\n\n        this.frenetFrames = path.computeFrenetFrames(tubularSegments, closed);\n\n        const numVertices = (tubularSegments + 1) * (radialSegments + 1);\n        const numIndices = tubularSegments * radialSegments * 6;\n        this.positions = new Float32Array(numVertices * 3);\n        this.normals = new Float32Array(numVertices * 3);\n        this.uvs = new Float32Array(numVertices * 2);\n        this.indices = numVertices > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        // create buffer data\n        this._generateAttributes();\n        this._generateIndices();\n\n        this.addAttribute('position', { size: 3, data: this.positions });\n        this.addAttribute('normal', { size: 3, data: this.normals });\n        this.addAttribute('uv', { size: 2, data: this.uvs });\n        this.setIndex({ data: this.indices });\n    }\n\n    _generateAttributes() {\n        for (let i = 0; i <= this.tubularSegments; i++) {\n            let ci = i;\n            if (i === this.tubularSegments) {\n                // if the geometry is not closed, generate the last row of vertices and normals\n                // at the regular position on the given path\n                // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n                ci = this.closed ? 0 : this.tubularSegments;\n            }\n\n            this.path.getPointAt(ci / this.tubularSegments, point);\n            // retrieve corresponding normal and binormal\n            const N = this.frenetFrames.normals[ci];\n            const B = this.frenetFrames.binormals[ci];\n\n            // generate normals and vertices for the current segment\n            for (let j = 0; j <= this.radialSegments; j++) {\n                const v = (j / this.radialSegments) * Math.PI * 2;\n                const sin = Math.sin(v);\n                const cos = -Math.cos(v);\n\n                const idx = i * (this.radialSegments + 1) + j;\n\n                // normal\n                normal.x = cos * N.x + sin * B.x;\n                normal.y = cos * N.y + sin * B.y;\n                normal.z = cos * N.z + sin * B.z;\n                // normal.normalize(); // ???\n                this.normals.set(normal, idx * 3);\n\n                // vertex\n                vertex.x = point.x + this.radius * normal.x;\n                vertex.y = point.y + this.radius * normal.y;\n                vertex.z = point.z + this.radius * normal.z;\n                this.positions.set(vertex, idx * 3);\n\n                // uv\n                uv.x = i / this.tubularSegments;\n                uv.y = j / this.radialSegments;\n                this.uvs.set(uv, idx * 2);\n            }\n        }\n    }\n\n    _generateIndices() {\n        for (let j = 1; j <= this.tubularSegments; j++) {\n            for (let i = 1; i <= this.radialSegments; i++) {\n                const a = (this.radialSegments + 1) * (j - 1) + (i - 1);\n                const b = (this.radialSegments + 1) * j + (i - 1);\n                const c = (this.radialSegments + 1) * j + i;\n                const d = (this.radialSegments + 1) * (j - 1) + i;\n\n                const idx = (j - 1) * this.radialSegments + (i - 1);\n                this.indices.set([a, b, d, b, c, d], idx * 6);\n            }\n        }\n    }\n}\n","import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class Post {\n    constructor(\n        gl,\n        {\n            width,\n            height,\n            dpr,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            minFilter = gl.LINEAR,\n            magFilter = gl.LINEAR,\n            geometry = new Triangle(gl),\n            targetOnly = null,\n            depth = true,\n        } = {}\n    ) {\n        this.gl = gl;\n\n        this.passes = [];\n\n        this.geometry = geometry;\n\n        this.uniform = { value: null };\n        this.targetOnly = targetOnly;\n\n        if (dpr) this.dpr = dpr;\n        if (width) this.width = width;\n        if (height) this.height = height;\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n        this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n\n        let options = {\n            dpr: this.dpr,\n            width: this.resolutionWidth,\n            height: this.resolutionHeight,\n            wrapS,\n            wrapT,\n            minFilter,\n            magFilter,\n            depth,\n        };\n\n        const fbo = (this.fbo = {\n            read: new RenderTarget(this.gl, options),\n            write: new RenderTarget(this.gl, options),\n            swap: () => {\n                let temp = fbo.read;\n                fbo.read = fbo.write;\n                fbo.write = temp;\n            },\n        });\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = { value: this.fbo.read.texture };\n\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    resize({ width, height, dpr } = {}) {\n        if (dpr) this.dpr = dpr;\n        if (width) this.width = width;\n        if (height) this.height = height;\n\n        dpr = this.dpr || this.gl.renderer.dpr;\n        this.resolutionWidth = Math.floor(this.width || this.gl.renderer.width * dpr);\n        this.resolutionHeight = Math.floor(this.height || this.gl.renderer.height * dpr);\n\n        this.fbo.read.setSize(this.resolutionWidth, this.resolutionHeight);\n        this.fbo.write.setSize(this.resolutionWidth, this.resolutionHeight);\n    }\n\n    // Uses same arguments as renderer.render, with addition of optional texture passed in to avoid scene render\n    render({ scene, camera, texture, target = null, update = true, sort = true, frustumCull = true, beforePostCallbacks }) {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        if (!texture) {\n            this.gl.renderer.render({\n                scene,\n                camera,\n                target: enabledPasses.length || (!target && this.targetOnly) ? this.fbo.write : target,\n                update,\n                sort,\n                frustumCull,\n            });\n            this.fbo.swap();\n\n            // Callback after rendering scene, but before post effects\n            if (beforePostCallbacks) beforePostCallbacks.forEach((f) => f && f());\n        }\n\n        enabledPasses.forEach((pass, i) => {\n            pass.mesh.program.uniforms[pass.textureUniform].value = !i && texture ? texture : this.fbo.read.texture;\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: i === enabledPasses.length - 1 && (target || !this.targetOnly) ? target : this.fbo.write,\n                clear: true,\n            });\n            this.fbo.swap();\n        });\n\n        this.uniform.value = this.fbo.read.texture;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n","import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst prevPos = /* @__PURE__ */ new Vec3();\nconst prevRot = /* @__PURE__ */ new Quat();\nconst prevScl = /* @__PURE__ */ new Vec3();\n\nconst nextPos = /* @__PURE__ */ new Vec3();\nconst nextRot = /* @__PURE__ */ new Quat();\nconst nextScl = /* @__PURE__ */ new Vec3();\n\nexport class Animation {\n    constructor({ objects, data }) {\n        this.objects = objects;\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = 1;\n        this.duration = data.frames.length - 1;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = this.elapsed % this.duration;\n\n        const floorFrame = Math.floor(elapsed);\n        const blend = elapsed - floorFrame;\n        const prevKey = this.data.frames[floorFrame];\n        const nextKey = this.data.frames[(floorFrame + 1) % this.duration];\n\n        this.objects.forEach((object, i) => {\n            prevPos.fromArray(prevKey.position, i * 3);\n            prevRot.fromArray(prevKey.quaternion, i * 4);\n            prevScl.fromArray(prevKey.scale, i * 3);\n\n            nextPos.fromArray(nextKey.position, i * 3);\n            nextRot.fromArray(nextKey.quaternion, i * 4);\n            nextScl.fromArray(nextKey.scale, i * 3);\n\n            prevPos.lerp(nextPos, blend);\n            prevRot.slerp(nextRot, blend);\n            prevScl.lerp(nextScl, blend);\n\n            object.position.lerp(prevPos, weight);\n            object.quaternion.slerp(prevRot, weight);\n            object.scale.lerp(prevScl, weight);\n        });\n    }\n}\n","import { Mesh } from '../core/Mesh.js';\nimport { Transform } from '../core/Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\nimport { Animation } from './Animation.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Skin extends Mesh {\n    constructor(gl, { rig, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n\n        this.createBones(rig);\n        this.createBoneTexture();\n        this.animations = [];\n\n        Object.assign(this.program.uniforms, {\n            boneTexture: { value: this.boneTexture },\n            boneTextureSize: { value: this.boneTextureSize },\n        });\n    }\n\n    createBones(rig) {\n        // Create root so that can simply update world matrix of whole skeleton\n        this.root = new Transform();\n\n        // Create bones\n        this.bones = [];\n        if (!rig.bones || !rig.bones.length) return;\n        for (let i = 0; i < rig.bones.length; i++) {\n            const bone = new Transform();\n\n            // Set initial values (bind pose)\n            bone.position.fromArray(rig.bindPose.position, i * 3);\n            bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\n            bone.scale.fromArray(rig.bindPose.scale, i * 3);\n\n            this.bones.push(bone);\n        }\n\n        // Once created, set the hierarchy\n        rig.bones.forEach((data, i) => {\n            this.bones[i].name = data.name;\n            if (data.parent === -1) return this.bones[i].setParent(this.root);\n            this.bones[i].setParent(this.bones[data.parent]);\n        });\n\n        // Then update to calculate world matrices\n        this.root.updateMatrixWorld(true);\n\n        // Store inverse of bind pose to calculate differences\n        this.bones.forEach((bone) => {\n            bone.bindInverse = new Mat4(...bone.worldMatrix).inverse();\n        });\n    }\n\n    createBoneTexture() {\n        if (!this.bones.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    addAnimation(data) {\n        const animation = new Animation({ objects: this.bones, data });\n        this.animations.push(animation);\n        return animation;\n    }\n\n    update() {\n        // Calculate combined animation weight\n        let total = 0;\n        this.animations.forEach((animation) => (total += animation.weight));\n\n        this.animations.forEach((animation, i) => {\n            // force first animation to set in order to reset frame\n            animation.update(total, i === 0);\n        });\n    }\n\n    draw({ camera } = {}) {\n        // Update world matrices manually, as not part of scene graph\n        this.root.updateMatrixWorld(true);\n\n        // Update bone texture\n        this.bones.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        if (this.boneTexture) this.boneTexture.needsUpdate = true;\n\n        super.draw({ camera });\n    }\n}\n","export function Text({\n    font,\n    text,\n    width = Infinity,\n    align = 'left',\n    size = 1,\n    letterSpacing = 0,\n    lineHeight = 1.4,\n    wordSpacing = 0,\n    wordBreak = false,\n}) {\n    const _this = this;\n    let glyphs, buffers;\n    let fontHeight, baseline, scale;\n\n    const newline = /\\n/;\n    const whitespace = /\\s/;\n\n    {\n        parseFont();\n        createGeometry();\n    }\n\n    function parseFont() {\n        glyphs = {};\n        font.chars.forEach((d) => (glyphs[d.char] = d));\n    }\n\n    function createGeometry() {\n        fontHeight = font.common.lineHeight;\n        baseline = font.common.base;\n\n        // Use baseline so that actual text height is as close to 'size' value as possible\n        scale = size / baseline;\n\n        // Strip spaces and newlines to get actual character length for buffers\n        let chars = text.replace(/[ \\n]/g, '');\n        let numChars = chars.length;\n\n        // Create output buffers\n        buffers = {\n            position: new Float32Array(numChars * 4 * 3),\n            uv: new Float32Array(numChars * 4 * 2),\n            id: new Float32Array(numChars * 4),\n            index: new Uint16Array(numChars * 6),\n        };\n\n        // Set values for buffers that don't require calculation\n        for (let i = 0; i < numChars; i++) {\n            buffers.id.set([i, i, i, i], i * 4);\n            buffers.index.set([i * 4, i * 4 + 2, i * 4 + 1, i * 4 + 1, i * 4 + 2, i * 4 + 3], i * 6);\n        }\n\n        layout();\n    }\n\n    function layout() {\n        const lines = [];\n\n        let cursor = 0;\n\n        let wordCursor = 0;\n        let wordWidth = 0;\n        let line = newLine();\n\n        function newLine() {\n            const line = {\n                width: 0,\n                glyphs: [],\n            };\n            lines.push(line);\n            wordCursor = cursor;\n            wordWidth = 0;\n            return line;\n        }\n\n        let maxTimes = 100;\n        let count = 0;\n        while (cursor < text.length && count < maxTimes) {\n            count++;\n\n            const char = text[cursor];\n\n            // Skip whitespace at start of line\n            if (!line.width && whitespace.test(char)) {\n                cursor++;\n                wordCursor = cursor;\n                wordWidth = 0;\n                continue;\n            }\n\n            // If newline char, skip to next line\n            if (newline.test(char)) {\n                cursor++;\n                line = newLine();\n                continue;\n            }\n\n            const glyph = glyphs[char] || glyphs[' '];\n\n            // Find any applicable kern pairs\n            if (line.glyphs.length) {\n                const prevGlyph = line.glyphs[line.glyphs.length - 1][0];\n                let kern = getKernPairOffset(glyph.id, prevGlyph.id) * scale;\n                line.width += kern;\n                wordWidth += kern;\n            }\n\n            // add char to line\n            line.glyphs.push([glyph, line.width]);\n\n            // calculate advance for next glyph\n            let advance = 0;\n\n            // If whitespace, update location of current word for line breaks\n            if (whitespace.test(char)) {\n                wordCursor = cursor;\n                wordWidth = 0;\n\n                // Add wordspacing\n                advance += wordSpacing * size;\n            } else {\n                // Add letterspacing\n                advance += letterSpacing * size;\n            }\n\n            advance += glyph.xadvance * scale;\n\n            line.width += advance;\n            wordWidth += advance;\n\n            // If width defined\n            if (line.width > width) {\n                // If can break words, undo latest glyph if line not empty and create new line\n                if (wordBreak && line.glyphs.length > 1) {\n                    line.width -= advance;\n                    line.glyphs.pop();\n                    line = newLine();\n                    continue;\n\n                    // If not first word, undo current word and cursor and create new line\n                } else if (!wordBreak && wordWidth !== line.width) {\n                    let numGlyphs = cursor - wordCursor + 1;\n                    line.glyphs.splice(-numGlyphs, numGlyphs);\n                    cursor = wordCursor;\n                    line.width -= wordWidth;\n                    line = newLine();\n                    continue;\n                }\n            }\n\n            cursor++;\n            // Reset infinite loop catch\n            count = 0;\n        }\n\n        // Remove last line if empty\n        if (!line.width) lines.pop();\n\n        populateBuffers(lines);\n    }\n\n    function populateBuffers(lines) {\n        const texW = font.common.scaleW;\n        const texH = font.common.scaleH;\n\n        // For all fonts tested, a little offset was needed to be right on the baseline, hence 0.07.\n        let y = 0.07 * size;\n        let j = 0;\n\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n            let line = lines[lineIndex];\n\n            for (let i = 0; i < line.glyphs.length; i++) {\n                const glyph = line.glyphs[i][0];\n                let x = line.glyphs[i][1];\n\n                if (align === 'center') {\n                    x -= line.width * 0.5;\n                } else if (align === 'right') {\n                    x -= line.width;\n                }\n\n                // If space, don't add to geometry\n                if (whitespace.test(glyph.char)) continue;\n\n                // Apply char sprite offsets\n                x += glyph.xoffset * scale;\n                y -= glyph.yoffset * scale;\n\n                // each letter is a quad. axis bottom left\n                let w = glyph.width * scale;\n                let h = glyph.height * scale;\n                buffers.position.set([x, y - h, 0, x, y, 0, x + w, y - h, 0, x + w, y, 0], j * 4 * 3);\n\n                let u = glyph.x / texW;\n                let uw = glyph.width / texW;\n                let v = 1.0 - glyph.y / texH;\n                let vh = glyph.height / texH;\n                buffers.uv.set([u, v - vh, u, v, u + uw, v - vh, u + uw, v], j * 4 * 2);\n\n                // Reset cursor to baseline\n                y += glyph.yoffset * scale;\n\n                j++;\n            }\n\n            y -= size * lineHeight;\n        }\n\n        _this.buffers = buffers;\n        _this.numLines = lines.length;\n        _this.height = _this.numLines * size * lineHeight;\n        _this.width = Math.max(...lines.map((line) => line.width));\n    }\n\n    function getKernPairOffset(id1, id2) {\n        for (let i = 0; i < font.kernings.length; i++) {\n            let k = font.kernings[i];\n            if (k.first < id1) continue;\n            if (k.second < id2) continue;\n            if (k.first > id1) return 0;\n            if (k.first === id1 && k.second > id2) return 0;\n            return k.amount;\n        }\n        return 0;\n    }\n\n    // Update buffers to layout with new layout\n    this.resize = function (options) {\n        ({ width } = options);\n        layout();\n    };\n\n    // Completely change text (like creating new Text)\n    this.update = function (options) {\n        ({ text } = options);\n        createGeometry();\n    };\n}\n","import { Program } from '../core/Program.js';\n\nconst vertex = /* glsl */ `\n    precision highp float;\n    precision highp int;\n\n    attribute vec3 position;\n    attribute vec3 normal;\n\n    uniform mat3 normalMatrix;\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    varying vec3 vNormal;\n\n    void main() {\n        vNormal = normalize(normalMatrix * normal);\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst fragment = /* glsl */ `\n    precision highp float;\n    precision highp int;\n\n    varying vec3 vNormal;\n\n    void main() {\n        gl_FragColor.rgb = normalize(vNormal);\n        gl_FragColor.a = 1.0;\n    }\n`;\n\nexport function NormalProgram(gl) {\n    return new Program(gl, {\n        vertex: vertex,\n        fragment: fragment,\n        cullFace: false,\n    });\n}\n","import { RenderTarget } from '../core/RenderTarget.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Triangle } from './Triangle.js';\n\nexport class Flowmap {\n    constructor(\n        gl,\n        {\n            size = 128, // default size of the render targets\n            falloff = 0.3, // size of the stamp, percentage of the size\n            alpha = 1, // opacity of the stamp\n            dissipation = 0.98, // affects the speed that the stamp fades. Closer to 1 is slower\n            type, // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n        } = {}\n    ) {\n        const _this = this;\n        this.gl = gl;\n\n        // output uniform containing render target textures\n        this.uniform = { value: null };\n\n        this.mask = {\n            read: null,\n            write: null,\n\n            // Helper function to ping pong the render targets and update the uniform\n            swap: () => {\n                let temp = _this.mask.read;\n                _this.mask.read = _this.mask.write;\n                _this.mask.write = temp;\n                _this.uniform.value = _this.mask.read.texture;\n            },\n        };\n\n        {\n            createFBOs();\n\n            this.aspect = 1;\n            this.mouse = new Vec2();\n            this.velocity = new Vec2();\n\n            this.mesh = initProgram();\n        }\n\n        function createFBOs() {\n            // Requested type not supported, fall back to half float\n            if (!type) type = gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES;\n\n            let minFilter = (() => {\n                if (gl.renderer.isWebgl2) return gl.LINEAR;\n                if (gl.renderer.extensions[`OES_texture_${type === gl.FLOAT ? '' : 'half_'}float_linear`]) return gl.LINEAR;\n                return gl.NEAREST;\n            })();\n\n            const options = {\n                width: size,\n                height: size,\n                type,\n                format: gl.RGBA,\n                internalFormat: gl.renderer.isWebgl2 ? (type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F) : gl.RGBA,\n                minFilter,\n                depth: false,\n            };\n\n            _this.mask.read = new RenderTarget(gl, options);\n            _this.mask.write = new RenderTarget(gl, options);\n            _this.mask.swap();\n        }\n\n        function initProgram() {\n            return new Mesh(gl, {\n                // Triangle that includes -1 to 1 range for 'position', and 0 to 1 range for 'uv'.\n                geometry: new Triangle(gl),\n\n                program: new Program(gl, {\n                    vertex,\n                    fragment,\n                    uniforms: {\n                        tMap: _this.uniform,\n\n                        uFalloff: { value: falloff * 0.5 },\n                        uAlpha: { value: alpha },\n                        uDissipation: { value: dissipation },\n\n                        // User needs to update these\n                        uAspect: { value: 1 },\n                        uMouse: { value: _this.mouse },\n                        uVelocity: { value: _this.velocity },\n                    },\n                    depthTest: false,\n                }),\n            });\n        }\n    }\n\n    update() {\n        this.mesh.program.uniforms.uAspect.value = this.aspect;\n\n        this.gl.renderer.render({\n            scene: this.mesh,\n            target: this.mask.write,\n            clear: false,\n        });\n        this.mask.swap();\n    }\n}\n\nconst vertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst fragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n\n    uniform float uFalloff;\n    uniform float uAlpha;\n    uniform float uDissipation;\n    \n    uniform float uAspect;\n    uniform vec2 uMouse;\n    uniform vec2 uVelocity;\n\n    varying vec2 vUv;\n\n    void main() {\n        vec4 color = texture2D(tMap, vUv) * uDissipation;\n\n        vec2 cursor = vUv - uMouse;\n        cursor.x *= uAspect;\n\n        vec3 stamp = vec3(uVelocity * vec2(1, -1), 1.0 - pow(1.0 - min(1.0, length(uVelocity)), 3.0));\n        float falloff = smoothstep(uFalloff, 0.0, length(cursor)) * uAlpha;\n\n        color.rgb = mix(color.rgb, stamp, vec3(falloff));\n\n        gl_FragColor = color;\n    }\n`;\n","import { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Texture } from '../core/Texture.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\nimport { Triangle } from './Triangle.js';\n\nexport class GPGPU {\n    constructor(\n        gl,\n        {\n            // Always pass in array of vec4s (RGBA values within texture)\n            data = new Float32Array(16),\n            geometry = new Triangle(gl),\n            type, // Pass in gl.FLOAT to force it, defaults to gl.HALF_FLOAT\n        }\n    ) {\n        this.gl = gl;\n        const initialData = data;\n        this.passes = [];\n        this.geometry = geometry;\n        this.dataLength = initialData.length / 4;\n\n        // Windows and iOS only like power of 2 textures\n        // Find smallest PO2 that fits data\n        this.size = Math.pow(2, Math.ceil(Math.log(Math.ceil(Math.sqrt(this.dataLength))) / Math.LN2));\n\n        // Create coords for output texture\n        this.coords = new Float32Array(this.dataLength * 2);\n        for (let i = 0; i < this.dataLength; i++) {\n            const x = (i % this.size) / this.size; // to add 0.5 to be center pixel ?\n            const y = Math.floor(i / this.size) / this.size;\n            this.coords.set([x, y], i * 2);\n        }\n\n        // Use original data if already correct length of PO2 texture, else copy to new array of correct length\n        const floatArray = (() => {\n            if (initialData.length === this.size * this.size * 4) {\n                return initialData;\n            } else {\n                const a = new Float32Array(this.size * this.size * 4);\n                a.set(initialData);\n                return a;\n            }\n        })();\n\n        // Create output texture uniform using input float texture with initial data\n        this.uniform = {\n            value: new Texture(gl, {\n                image: floatArray,\n                target: gl.TEXTURE_2D,\n                type: gl.FLOAT,\n                format: gl.RGBA,\n                internalFormat: gl.renderer.isWebgl2 ? gl.RGBA32F : gl.RGBA,\n                wrapS: gl.CLAMP_TO_EDGE,\n                wrapT: gl.CLAMP_TO_EDGE,\n                generateMipmaps: false,\n                minFilter: gl.NEAREST,\n                magFilter: gl.NEAREST,\n                width: this.size,\n                flipY: false,\n            }),\n        };\n\n        // Create FBOs\n        const options = {\n            width: this.size,\n            height: this.size,\n            type: type || gl.HALF_FLOAT || gl.renderer.extensions['OES_texture_half_float'].HALF_FLOAT_OES,\n            format: gl.RGBA,\n            internalFormat: gl.renderer.isWebgl2 ? (type === gl.FLOAT ? gl.RGBA32F : gl.RGBA16F) : gl.RGBA,\n            minFilter: gl.NEAREST,\n            depth: false,\n            unpackAlignment: 1,\n        };\n\n        this.fbo = {\n            read: new RenderTarget(gl, options),\n            write: new RenderTarget(gl, options),\n            swap: () => {\n                let temp = this.fbo.read;\n                this.fbo.read = this.fbo.write;\n                this.fbo.write = temp;\n                this.uniform.value = this.fbo.read.texture;\n            },\n        };\n    }\n\n    addPass({ vertex = defaultVertex, fragment = defaultFragment, uniforms = {}, textureUniform = 'tMap', enabled = true } = {}) {\n        uniforms[textureUniform] = this.uniform;\n        const program = new Program(this.gl, { vertex, fragment, uniforms });\n        const mesh = new Mesh(this.gl, { geometry: this.geometry, program });\n\n        const pass = {\n            mesh,\n            program,\n            uniforms,\n            enabled,\n            textureUniform,\n        };\n\n        this.passes.push(pass);\n        return pass;\n    }\n\n    render() {\n        const enabledPasses = this.passes.filter((pass) => pass.enabled);\n\n        enabledPasses.forEach((pass, i) => {\n            this.gl.renderer.render({\n                scene: pass.mesh,\n                target: this.fbo.write,\n                clear: false,\n            });\n            this.fbo.swap();\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec2 uv;\n    attribute vec2 position;\n\n    varying vec2 vUv;\n\n    void main() {\n        vUv = uv;\n        gl_Position = vec4(position, 0, 1);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform sampler2D tMap;\n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor = texture2D(tMap, vUv);\n    }\n`;\n","import { Geometry } from '../core/Geometry.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Color } from '../math/Color.js';\n\nconst tmp = /* @__PURE__ */ new Vec3();\n\nexport class Polyline {\n    constructor(\n        gl,\n        {\n            points, // Array of Vec3s\n            vertex = defaultVertex,\n            fragment = defaultFragment,\n            uniforms = {},\n            attributes = {}, // For passing in custom attribs\n        }\n    ) {\n        this.gl = gl;\n        this.points = points;\n        this.count = points.length;\n\n        // Create buffers\n        this.position = new Float32Array(this.count * 3 * 2);\n        this.prev = new Float32Array(this.count * 3 * 2);\n        this.next = new Float32Array(this.count * 3 * 2);\n        const side = new Float32Array(this.count * 1 * 2);\n        const uv = new Float32Array(this.count * 2 * 2);\n        const index = new Uint16Array((this.count - 1) * 3 * 2);\n\n        // Set static buffers\n        for (let i = 0; i < this.count; i++) {\n            side.set([-1, 1], i * 2);\n            const v = i / (this.count - 1);\n            uv.set([0, v, 1, v], i * 4);\n\n            if (i === this.count - 1) continue;\n            const ind = i * 2;\n            index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n            index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n        }\n\n        const geometry = (this.geometry = new Geometry(\n            gl,\n            Object.assign(attributes, {\n                position: { size: 3, data: this.position },\n                prev: { size: 3, data: this.prev },\n                next: { size: 3, data: this.next },\n                side: { size: 1, data: side },\n                uv: { size: 2, data: uv },\n                index: { size: 1, data: index },\n            })\n        ));\n\n        // Populate dynamic buffers\n        this.updateGeometry();\n\n        if (!uniforms.uResolution) this.resolution = uniforms.uResolution = { value: new Vec2() };\n        if (!uniforms.uDPR) this.dpr = uniforms.uDPR = { value: 1 };\n        if (!uniforms.uThickness) this.thickness = uniforms.uThickness = { value: 1 };\n        if (!uniforms.uColor) this.color = uniforms.uColor = { value: new Color('#000') };\n        if (!uniforms.uMiter) this.miter = uniforms.uMiter = { value: 1 };\n\n        // Set size uniforms' values\n        this.resize();\n\n        const program = (this.program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms,\n        }));\n\n        this.mesh = new Mesh(gl, { geometry, program });\n    }\n\n    updateGeometry() {\n        this.points.forEach((p, i) => {\n            p.toArray(this.position, i * 3 * 2);\n            p.toArray(this.position, i * 3 * 2 + 3);\n\n            if (!i) {\n                // If first point, calculate prev using the distance to 2nd point\n                tmp.copy(p)\n                    .sub(this.points[i + 1])\n                    .add(p);\n                tmp.toArray(this.prev, i * 3 * 2);\n                tmp.toArray(this.prev, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.next, (i - 1) * 3 * 2);\n                p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n            }\n\n            if (i === this.points.length - 1) {\n                // If last point, calculate next using distance to 2nd last point\n                tmp.copy(p)\n                    .sub(this.points[i - 1])\n                    .add(p);\n                tmp.toArray(this.next, i * 3 * 2);\n                tmp.toArray(this.next, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.prev, (i + 1) * 3 * 2);\n                p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n            }\n        });\n\n        this.geometry.attributes.position.needsUpdate = true;\n        this.geometry.attributes.prev.needsUpdate = true;\n        this.geometry.attributes.next.needsUpdate = true;\n    }\n\n    // Only need to call if not handling resolution uniforms manually\n    resize() {\n        // Update automatic uniforms if not overridden\n        if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n        if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    precision highp float;\n\n    attribute vec3 position;\n    attribute vec3 next;\n    attribute vec3 prev;\n    attribute vec2 uv;\n    attribute float side;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform vec2 uResolution;\n    uniform float uDPR;\n    uniform float uThickness;\n    uniform float uMiter;\n\n    varying vec2 vUv;\n\n    vec4 getPosition() {\n        mat4 mvp = projectionMatrix * modelViewMatrix;\n        vec4 current = mvp * vec4(position, 1);\n        vec4 nextPos = mvp * vec4(next, 1);\n        vec4 prevPos = mvp * vec4(prev, 1);\n\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \n        vec2 currentScreen = current.xy / current.w * aspect;\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\n    \n        vec2 dir1 = normalize(currentScreen - prevScreen);\n        vec2 dir2 = normalize(nextScreen - currentScreen);\n        vec2 dir = normalize(dir1 + dir2);\n    \n        vec2 normal = vec2(-dir.y, dir.x);\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\n        normal /= aspect;\n\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n        float pixelWidth = current.w * pixelWidthRatio;\n        normal *= pixelWidth * uThickness;\n        current.xy -= normal * side;\n    \n        return current;\n    }\n\n    void main() {\n        vUv = uv;\n        gl_Position = getPosition();\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform vec3 uColor;\n    \n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor.rgb = uColor;\n        gl_FragColor.a = 1.0;\n    }\n`;\n","import { Camera } from '../core/Camera.js';\nimport { Program } from '../core/Program.js';\nimport { RenderTarget } from '../core/RenderTarget.js';\n\nexport class Shadow {\n    constructor(gl, { light = new Camera(gl), width = 1024, height = width }) {\n        this.gl = gl;\n\n        this.light = light;\n\n        this.target = new RenderTarget(gl, { width, height });\n        this.targetUniform = { value: this.target.texture };\n\n        this.depthProgram = new Program(gl, {\n            vertex: defaultVertex,\n            fragment: defaultFragment,\n            cullFace: false,\n        });\n\n        this.castMeshes = [];\n    }\n\n    add({\n        mesh,\n        receive = true,\n        cast = true,\n        vertex = defaultVertex,\n        fragment = defaultFragment,\n        uniformProjection = 'shadowProjectionMatrix',\n        uniformView = 'shadowViewMatrix',\n        uniformTexture = 'tShadow',\n    }) {\n        // Add uniforms to existing program\n        if (receive && !mesh.program.uniforms[uniformProjection]) {\n            mesh.program.uniforms[uniformProjection] = { value: this.light.projectionMatrix };\n            mesh.program.uniforms[uniformView] = { value: this.light.viewMatrix };\n            mesh.program.uniforms[uniformTexture] = this.targetUniform;\n        }\n\n        if (!cast) return;\n        this.castMeshes.push(mesh);\n\n        // Store program for when switching between depth override\n        mesh.colorProgram = mesh.program;\n\n        // Check if depth program already attached\n        if (mesh.depthProgram) return;\n\n        // Use global depth override if nothing custom passed in\n        if (vertex === defaultVertex && fragment === defaultFragment) {\n            mesh.depthProgram = this.depthProgram;\n            return;\n        }\n\n        // Create custom override program\n        mesh.depthProgram = new Program(this.gl, {\n            vertex,\n            fragment,\n            cullFace: false,\n        });\n    }\n\n    setSize({ width = 1024, height = width }) {\n        this.target = new RenderTarget(this.gl, { width, height });\n        this.targetUniform.value = this.target.texture;\n    }\n\n    render({ scene }) {\n        // For depth render, replace program with depth override.\n        // Hide meshes not casting shadows.\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.depthProgram;\n            } else {\n                node.isForceVisibility = node.visible;\n                node.visible = false;\n            }\n        });\n\n        // Render the depth shadow map using the light as the camera\n        this.gl.renderer.render({\n            scene,\n            camera: this.light,\n            target: this.target,\n        });\n\n        // Then switch the program back to the normal one\n        scene.traverse((node) => {\n            if (!node.draw) return;\n            if (!!~this.castMeshes.indexOf(node)) {\n                node.program = node.colorProgram;\n            } else {\n                node.visible = node.isForceVisibility;\n            }\n        });\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    attribute vec3 position;\n    attribute vec2 uv;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n\n    void main() {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    vec4 packRGBA (float v) {\n        vec4 pack = fract(vec4(1.0, 255.0, 65025.0, 16581375.0) * v);\n        pack -= pack.yzww * vec2(1.0 / 255.0, 0.0).xxxy;\n        return pack;\n    }\n\n    void main() {\n        gl_FragColor = packRGBA(gl_FragCoord.z);\n    }\n`;\n","import { Texture } from '../core/Texture.js';\n\n// TODO: Support cubemaps\n// Generate textures using https://github.com/TimvanScherpenzeel/texture-compressor\n\nexport class KTXTexture extends Texture {\n    constructor(gl, { buffer, wrapS = gl.CLAMP_TO_EDGE, wrapT = gl.CLAMP_TO_EDGE, anisotropy = 0, minFilter, magFilter } = {}) {\n        super(gl, {\n            generateMipmaps: false,\n            wrapS,\n            wrapT,\n            anisotropy,\n            minFilter,\n            magFilter,\n        });\n\n        if (buffer) return this.parseBuffer(buffer);\n    }\n\n    parseBuffer(buffer) {\n        const ktx = new KhronosTextureContainer(buffer);\n        ktx.mipmaps.isCompressedTexture = true;\n\n        // Update texture\n        this.image = ktx.mipmaps;\n        this.internalFormat = ktx.glInternalFormat;\n        if (ktx.numberOfMipmapLevels > 1) {\n            if (this.minFilter === this.gl.LINEAR) this.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        } else {\n            if (this.minFilter === this.gl.NEAREST_MIPMAP_LINEAR) this.minFilter = this.gl.LINEAR;\n        }\n\n        // TODO: support cube maps\n        // ktx.numberOfFaces\n    }\n}\n\nfunction KhronosTextureContainer(buffer) {\n    const idCheck = [0xab, 0x4b, 0x54, 0x58, 0x20, 0x31, 0x31, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a];\n    const id = new Uint8Array(buffer, 0, 12);\n    for (let i = 0; i < id.length; i++) if (id[i] !== idCheck[i]) return console.error('File missing KTX identifier');\n\n    // TODO: Is this always 4? Tested: [android, macos]\n    const size = Uint32Array.BYTES_PER_ELEMENT;\n    const head = new DataView(buffer, 12, 13 * size);\n    const littleEndian = head.getUint32(0, true) === 0x04030201;\n    const glType = head.getUint32(1 * size, littleEndian);\n    if (glType !== 0) return console.warn('only compressed formats currently supported');\n    this.glInternalFormat = head.getUint32(4 * size, littleEndian);\n    let width = head.getUint32(6 * size, littleEndian);\n    let height = head.getUint32(7 * size, littleEndian);\n    this.numberOfFaces = head.getUint32(10 * size, littleEndian);\n    this.numberOfMipmapLevels = Math.max(1, head.getUint32(11 * size, littleEndian));\n    const bytesOfKeyValueData = head.getUint32(12 * size, littleEndian);\n\n    this.mipmaps = [];\n    let offset = 12 + 13 * 4 + bytesOfKeyValueData;\n    for (let level = 0; level < this.numberOfMipmapLevels; level++) {\n        const levelSize = new Int32Array(buffer, offset, 1)[0]; // size per face, since not supporting array cubemaps\n        offset += 4; // levelSize field\n        for (let face = 0; face < this.numberOfFaces; face++) {\n            const data = new Uint8Array(buffer, offset, levelSize);\n            this.mipmaps.push({ data, width, height });\n            offset += levelSize;\n            offset += 3 - ((levelSize + 3) % 4); // add padding for odd sized image\n        }\n        width = width >> 1;\n        height = height >> 1;\n    }\n}\n","import { Texture } from '../core/Texture.js';\nimport { KTXTexture } from './KTXTexture.js';\n\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\n\nlet cache = {};\nconst supportedExtensions = [];\n\nexport class TextureLoader {\n    static load(\n        gl,\n        {\n            src, // string or object of extension:src key-values\n            // {\n            //     pvrtc: '...ktx',\n            //     s3tc: '...ktx',\n            //     etc: '...ktx',\n            //     etc1: '...ktx',\n            //     astc: '...ktx',\n            //     webp: '...webp',\n            //     jpg: '...jpg',\n            //     png: '...png',\n            // }\n\n            // Only props relevant to KTXTexture\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            anisotropy = 0,\n\n            // For regular images\n            format = gl.RGBA,\n            internalFormat = format,\n            generateMipmaps = true,\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = true,\n        } = {}\n    ) {\n        const support = this.getSupportedExtensions(gl);\n        let ext = 'none';\n\n        // If src is string, determine which format from the extension\n        if (typeof src === 'string') {\n            ext = src.split('.').pop().split('?')[0].toLowerCase();\n        }\n\n        // If src is object, use supported extensions and provided list to choose best option\n        // Get first supported match, so put in order of preference\n        if (typeof src === 'object') {\n            for (const prop in src) {\n                if (support.includes(prop.toLowerCase())) {\n                    ext = prop.toLowerCase();\n                    src = src[prop];\n                    break;\n                }\n            }\n        }\n\n        // Stringify props\n        const cacheID = src + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id;\n\n        // Check cache for existing texture\n        if (cache[cacheID]) return cache[cacheID];\n\n        let texture;\n        switch (ext) {\n            case 'ktx':\n            case 'pvrtc':\n            case 's3tc':\n            case 'etc':\n            case 'etc1':\n            case 'astc':\n                // Load compressed texture using KTX format\n                texture = new KTXTexture(gl, {\n                    src,\n                    wrapS,\n                    wrapT,\n                    anisotropy,\n                    minFilter,\n                    magFilter,\n                });\n                texture.loaded = this.loadKTX(src, texture);\n                break;\n            case 'webp':\n            case 'jpg':\n            case 'jpeg':\n            case 'png':\n                texture = new Texture(gl, {\n                    wrapS,\n                    wrapT,\n                    anisotropy,\n                    format,\n                    internalFormat,\n                    generateMipmaps,\n                    minFilter,\n                    magFilter,\n                    premultiplyAlpha,\n                    unpackAlignment,\n                    flipY,\n                });\n                texture.loaded = this.loadImage(gl, src, texture, flipY);\n                break;\n            default:\n                console.warn('No supported format supplied');\n                texture = new Texture(gl);\n        }\n\n        texture.ext = ext;\n        cache[cacheID] = texture;\n        return texture;\n    }\n\n    static getSupportedExtensions(gl) {\n        if (supportedExtensions.length) return supportedExtensions;\n\n        const extensions = {\n            pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc'),\n            // etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n            astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc'),\n            bc7: gl.renderer.getExtension('EXT_texture_compression_bptc'),\n        };\n\n        for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext);\n\n        // Formats supported by all\n        supportedExtensions.push('png', 'jpg', 'webp');\n\n        return supportedExtensions;\n    }\n\n    static loadKTX(src, texture) {\n        return fetch(src)\n            .then((res) => res.arrayBuffer())\n            .then((buffer) => texture.parseBuffer(buffer));\n    }\n\n    static loadImage(gl, src, texture, flipY) {\n        return decodeImage(src, flipY).then((imgBmp) => {\n            // Catch non POT textures for WebGL1 and update params to avoid errors\n            if (!gl.renderer.isWebgl2 && (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height))) {\n                if (texture.generateMipmaps) texture.generateMipmaps = false;\n                if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n                if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n            }\n\n            texture.image = imgBmp;\n\n            // For createImageBitmap, close once uploaded\n            texture.onUpdate = () => {\n                if (imgBmp.close) imgBmp.close();\n                texture.onUpdate = null;\n            };\n\n            return imgBmp;\n        });\n    }\n\n    static clearCache() {\n        cache = {};\n    }\n}\n\nfunction powerOfTwo(value) {\n    // (width & (width - 1)) !== 0\n    return Math.log2(value) % 1 === 0;\n}\n\nfunction decodeImage(src, flipY) {\n    return new Promise((resolve, reject) => {\n        if (isCreateImageBitmap()) {\n            fetch(src, { mode: 'cors' })\n                .then((r) => r.blob())\n                .then((b) => createImageBitmap(b, { imageOrientation: flipY ? 'flipY' : 'none', premultiplyAlpha: 'none' }))\n                .then(resolve)\n                .catch((err) => reject(err));\n        } else {\n            const img = new Image();\n\n            img.crossOrigin = '';\n            img.src = src;\n            img.onerror = ({ type }) => reject(`${type}: Loading image`);\n            img.onload = () => resolve(img);\n        }\n    });\n}\n\nfunction isCreateImageBitmap() {\n    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n    if (!isChrome) return false;\n    try {\n        createImageBitmap;\n    } catch (e) {\n        return false;\n    }\n    return true;\n}\n","import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = /* @__PURE__ */ new Vec3();\nconst tmpVec3B = /* @__PURE__ */ new Vec3();\nconst tmpVec3C = /* @__PURE__ */ new Vec3();\nconst tmpVec3D = /* @__PURE__ */ new Vec3();\n\nconst tmpQuatA = /* @__PURE__ */ new Quat();\nconst tmpQuatB = /* @__PURE__ */ new Quat();\nconst tmpQuatC = /* @__PURE__ */ new Quat();\nconst tmpQuatD = /* @__PURE__ */ new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = !this.duration\n            ? 0\n            : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            if (!this.duration) {\n                let val = tmpVec3A;\n                let size = 3;\n                if (transform === 'quaternion') {\n                    val = tmpQuatA;\n                    size = 4;\n                }\n                val.fromArray(values, 0);\n                if (size === 4) node[transform].slerp(val, weight);\n                else node[transform].lerp(val, weight);\n                return;\n            }\n\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n","import { Mesh } from '../core/Mesh.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst identity = /* @__PURE__ */ new Mat4();\n\nexport class GLTFSkin extends Mesh {\n    constructor(gl, { skeleton, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n        this.skeleton = skeleton;\n        this.program = program;\n        this.createBoneTexture();\n    }\n\n    createBoneTexture() {\n        if (!this.skeleton.joints.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    updateUniforms() {\n        // Update bone texture\n        this.skeleton.joints.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        this.boneTexture.needsUpdate = true;\n        // Reset for programs shared between multiple skins\n        this.program.uniforms.boneTexture.value = this.boneTexture;\n        this.program.uniforms.boneTextureSize.value = this.boneTextureSize;\n    }\n\n    draw({ camera } = {}) {\n        if (!this.program.uniforms.boneTexture) {\n            Object.assign(this.program.uniforms, {\n                boneTexture: { value: this.boneTexture },\n                boneTextureSize: { value: this.boneTextureSize },\n            });\n        }\n\n        this.updateUniforms();\n\n        // Switch the world matrix with identity to ignore any transforms\n        // on the mesh itself - only use skeleton's transforms\n        const _worldMatrix = this.worldMatrix;\n        this.worldMatrix = identity;\n\n        super.draw({ camera });\n\n        // Switch back to leave identity untouched\n        this.worldMatrix = _worldMatrix;\n    }\n}\n","import { Transform } from '../core/Transform.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec4 } from '../math/Vec4.js';\n\nexport class InstancedMesh extends Mesh {\n    constructor(...args) {\n        super(...args);\n\n        // Skip renderer frustum culling\n        this.frustumCulled = false;\n        this.isInstancedMesh = true;\n    }\n\n    addFrustumCull() {\n        this.instanceTransforms = null;\n        this.instanceLightmapScaleOffset = null;\n        this.totalInstanceCount = 0;\n        this.frustumCullFunction = null;\n        this.instanceRenderList = null;\n\n        // Get instanced mesh\n        if (!this.geometry.attributes.instanceMatrix)\n            console.error(`mesh ${this.name ? `\"${this.name}\" ` : ``}missing instanceMatrix attribute; unable to frustum cull`);\n\n        // Make list of transforms from instanceMatrix\n        const matrixData = this.geometry.attributes.instanceMatrix.data;\n        this.instanceTransforms = [];\n        for (let i = 0, j = 0; i < matrixData.length; i += 16, j++) {\n            const transform = new Transform();\n            transform.index = j;\n            transform.matrix.fromArray(matrixData, i);\n            transform.decompose();\n            this.instanceTransforms.push(transform);\n            // Add transforms to parent to update world matrices\n            transform.setParent(this.parent);\n        }\n        this.totalInstanceCount = this.instanceTransforms.length;\n\n        // Check for lightmap attributes - attach to transform\n        if (!!this.geometry.attributes.lightmapScaleOffset) {\n            const lightmapData = this.geometry.attributes.lightmapScaleOffset.data;\n            for (let i = 0, j = 0; i < lightmapData.length; i += 4, j++) {\n                this.instanceTransforms[j].lightmapData = new Vec4().fromArray(lightmapData, i);\n            }\n        }\n\n        this.frustumCullFunction = ({ camera }) => {\n            // frustum cull transforms each frame - pass world matrix\n            this.instanceRenderList = [];\n            this.instanceTransforms.forEach((transform) => {\n                if (!camera.frustumIntersectsMesh(this, transform.worldMatrix)) return;\n                this.instanceRenderList.push(transform);\n            });\n\n            // update instanceMatrix and instancedCount with visible\n            this.instanceRenderList.forEach((transform, i) => {\n                transform.matrix.toArray(this.geometry.attributes.instanceMatrix.data, i * 16);\n\n                // Update lightmap attr\n                if (transform.lightmapData) {\n                    transform.lightmapData.toArray(this.geometry.attributes.lightmapScaleOffset.data, i * 4);\n                    this.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                }\n            });\n            this.geometry.instancedCount = this.instanceRenderList.length;\n            this.geometry.attributes.instanceMatrix.needsUpdate = true;\n        };\n\n        this.onBeforeRender(this.frustumCullFunction);\n    }\n\n    removeFrustumCull() {\n        this.offBeforeRender(this.frustumCullFunction);\n        this.geometry.instancedCount = this.totalInstanceCount;\n        this.instanceTransforms.forEach((transform, i) => {\n            transform.matrix.toArray(this.geometry.attributes.instanceMatrix.data, i * 16);\n\n            // Update lightmap attr\n            if (transform.lightmapData) {\n                transform.lightmapData.toArray(this.geometry.attributes.lightmapScaleOffset.data, i * 4);\n                this.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n            }\n        });\n        this.geometry.attributes.instanceMatrix.needsUpdate = true;\n    }\n}\n","import { Geometry } from '../core/Geometry.js';\nimport { Transform } from '../core/Transform.js';\nimport { Texture } from '../core/Texture.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Camera } from '../core/Camera.js';\nimport { GLTFAnimation } from './GLTFAnimation.js';\nimport { GLTFSkin } from './GLTFSkin.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { NormalProgram } from './NormalProgram.js';\nimport { InstancedMesh } from './InstancedMesh.js';\n\n// TODO\n// [ ] Morph targets\n// [ ] Materials\n// [ ] Sparse accessor packing? For morph targets basically\n// [ ] Option to turn off GPU instancing?\n// [ ] Spot lights\n\nconst TYPE_ARRAY = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array,\n    'image/jpeg': Uint8Array,\n    'image/png': Uint8Array,\n    'image/webp': Uint8Array,\n};\n\nconst TYPE_SIZE = {\n    SCALAR: 1,\n    VEC2: 2,\n    VEC3: 3,\n    VEC4: 4,\n    MAT2: 4,\n    MAT3: 9,\n    MAT4: 16,\n};\n\nconst ATTRIBUTES = {\n    POSITION: 'position',\n    NORMAL: 'normal',\n    TANGENT: 'tangent',\n    TEXCOORD_0: 'uv',\n    TEXCOORD_1: 'uv2',\n    COLOR_0: 'color',\n    WEIGHTS_0: 'skinWeight',\n    JOINTS_0: 'skinIndex',\n};\n\nconst TRANSFORMS = {\n    translation: 'position',\n    rotation: 'quaternion',\n    scale: 'scale',\n};\n\nexport class GLTFLoader {\n    static setDracoManager(manager) {\n        this.dracoManager = manager;\n    }\n\n    static setBasisManager(manager) {\n        this.basisManager = manager;\n    }\n\n    static async load(gl, src) {\n        const dir = src.split('/').slice(0, -1).join('/') + '/';\n\n        // Load main description json\n        const desc = await this.parseDesc(src);\n\n        return this.parse(gl, desc, dir);\n    }\n\n    static async parse(gl, desc, dir) {\n        if (desc.asset === undefined || desc.asset.version[0] < 2)\n            console.warn('Only GLTF >=2.0 supported. Attempting to parse.');\n\n        if (desc.extensionsRequired?.includes('KHR_draco_mesh_compression') && !this.dracoManager)\n            console.warn('KHR_draco_mesh_compression extension required but no manager supplied. Use .setDracoManager()');\n\n        if (desc.extensionsRequired?.includes('KHR_texture_basisu') && !this.basisManager)\n            console.warn('KHR_texture_basisu extension required but no manager supplied. Use .setBasisManager()');\n\n        // Load buffers async\n        const buffers = await this.loadBuffers(desc, dir);\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        gl.renderer.bindVertexArray(null);\n\n        // Create gl buffers from bufferViews\n        const bufferViews = this.parseBufferViews(gl, desc, buffers);\n\n        // Create images from either bufferViews or separate image files\n        const images = await this.parseImages(gl, desc, dir, bufferViews);\n\n        const textures = this.parseTextures(gl, desc, images);\n\n        // Just pass through material data for now\n        const materials = this.parseMaterials(gl, desc, textures);\n\n        // Fetch the inverse bind matrices for skeleton joints\n        const skins = this.parseSkins(gl, desc, bufferViews);\n\n        // Create geometries for each mesh primitive\n        const meshes = await this.parseMeshes(gl, desc, bufferViews, materials, skins);\n\n        // Create transforms, meshes and hierarchy\n        const [nodes, cameras] = this.parseNodes(gl, desc, meshes, skins, images);\n\n        // Place nodes in skeletons\n        this.populateSkins(skins, nodes);\n\n        // Create animation handlers\n        const animations = this.parseAnimations(gl, desc, nodes, bufferViews);\n\n        // Get top level nodes for each scene\n        const scenes = this.parseScenes(desc, nodes);\n        const scene = scenes[desc.scene];\n\n        // Create uniforms for scene lights (TODO: light linking?)\n        const lights = this.parseLights(gl, desc, nodes, scenes);\n\n        // Remove null nodes (instanced transforms)\n        for (let i = nodes.length; i >= 0; i--) if (!nodes[i]) nodes.splice(i, 1);\n\n        return {\n            json: desc,\n            buffers,\n            bufferViews,\n            cameras,\n            images,\n            textures,\n            materials,\n            meshes,\n            nodes,\n            lights,\n            animations,\n            scenes,\n            scene,\n        };\n    }\n\n    static parseDesc(src) {\n        return fetch(src, { mode: 'cors' })\n            .then((res) => res.arrayBuffer())\n            .then((data) => {\n                const textDecoder = new TextDecoder();\n                if (textDecoder.decode(new Uint8Array(data, 0, 4)) === 'glTF') {\n                    return this.unpackGLB(data);\n                } else {\n                    return JSON.parse(textDecoder.decode(data));\n                }\n            });\n    }\n\n    // From https://github.com/donmccurdy/glTF-Transform/blob/e4108cc/packages/core/src/io/io.ts#L32\n    static unpackGLB(glb) {\n        // Decode and verify GLB header\n        const header = new Uint32Array(glb, 0, 3);\n        if (header[0] !== 0x46546c67) {\n            throw new Error('Invalid glTF asset.');\n        } else if (header[1] !== 2) {\n            throw new Error(`Unsupported glTF binary version, \"${header[1]}\".`);\n        }\n        // Decode and verify chunk headers\n        const jsonChunkHeader = new Uint32Array(glb, 12, 2);\n        const jsonByteOffset = 20;\n        const jsonByteLength = jsonChunkHeader[0];\n        if (jsonChunkHeader[1] !== 0x4e4f534a) {\n            throw new Error('Unexpected GLB layout.');\n        }\n\n        // Decode JSON\n        const jsonText = new TextDecoder().decode(glb.slice(jsonByteOffset, jsonByteOffset + jsonByteLength));\n        const json = JSON.parse(jsonText);\n        // JSON only\n        if (jsonByteOffset + jsonByteLength === glb.byteLength) return json;\n\n        const binaryChunkHeader = new Uint32Array(glb, jsonByteOffset + jsonByteLength, 2);\n        if (binaryChunkHeader[1] !== 0x004e4942) {\n            throw new Error('Unexpected GLB layout.');\n        }\n        // Decode content\n        const binaryByteOffset = jsonByteOffset + jsonByteLength + 8;\n        const binaryByteLength = binaryChunkHeader[0];\n        const binary = glb.slice(binaryByteOffset, binaryByteOffset + binaryByteLength);\n        // Attach binary to buffer\n        json.buffers[0].binary = binary;\n        return json;\n    }\n\n    // ThreeJS GLTF Loader https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js#L1085\n    static resolveURI(uri, dir) {\n        // Invalid URI\n        if (typeof uri !== 'string' || uri === '') return '';\n\n        // Host Relative URI\n        if (/^https?:\\/\\//i.test(dir) && /^\\//.test(uri)) {\n            dir = dir.replace(/(^https?:\\/\\/[^\\/]+).*/i, '$1');\n        }\n\n        // Absolute URI http://, https://, //\n        if (/^(https?:)?\\/\\//i.test(uri)) return uri;\n\n        // Data URI\n        if (/^data:.*,.*$/i.test(uri)) return uri;\n\n        // Blob URI\n        if (/^blob:.*$/i.test(uri)) return uri;\n\n        // Relative URI\n        return dir + uri;\n    }\n\n    static loadBuffers(desc, dir) {\n        if (!desc.buffers) return null;\n        return Promise.all(\n            desc.buffers.map((buffer) => {\n                // For GLB, binary buffer ready to go\n                if (buffer.binary) return buffer.binary;\n                const uri = this.resolveURI(buffer.uri, dir);\n                return fetch(uri, { mode: 'cors' }).then((res) => res.arrayBuffer());\n            })\n        );\n    }\n\n    static parseBufferViews(gl, desc, buffers) {\n        if (!desc.bufferViews) return null;\n        const bufferViews = desc.bufferViews;\n\n        desc.meshes &&\n            desc.meshes.forEach(({ primitives }) => {\n                primitives.forEach(({ attributes, indices, extensions }) => {\n                    // Flag bufferView as an attribute, so it knows to create a gl buffer\n                    for (const attr in attributes) {\n                        const accessor = desc.accessors[attributes[attr]];\n                        if (accessor.bufferView === undefined && !!extensions) {\n                            // Draco extension buffer view\n                            if (extensions.KHR_draco_mesh_compression) {\n                                accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n                                bufferViews[accessor.bufferView].isDraco = true;\n                            }\n                        }\n                        bufferViews[accessor.bufferView].isAttribute = true;\n                    }\n\n                    if (indices !== undefined) {\n                        const accessor = desc.accessors[indices];\n                        if (accessor.bufferView === undefined && !!extensions) {\n                            // Draco extension buffer view\n                            if (extensions.KHR_draco_mesh_compression) {\n                                accessor.bufferView = extensions.KHR_draco_mesh_compression.bufferView;\n                                bufferViews[accessor.bufferView].isDraco = true;\n                            }\n                        }\n                        bufferViews[accessor.bufferView].isAttribute = true;\n\n                        // Make sure indices bufferView have a target property for gl buffer binding\n                        bufferViews[accessor.bufferView].target = gl.ELEMENT_ARRAY_BUFFER;\n                    }\n                });\n            });\n\n        // Get componentType of each bufferView from the accessors\n        desc.accessors.forEach(({ bufferView: bufferViewIndex, componentType }) => {\n            if (bufferViewIndex === undefined) return;\n            bufferViews[bufferViewIndex].componentType = componentType;\n        });\n\n        // Get mimetype of bufferView from images\n        desc.images &&\n            desc.images.forEach(({ uri, bufferView: bufferViewIndex, mimeType }) => {\n                if (bufferViewIndex === undefined) return;\n                bufferViews[bufferViewIndex].mimeType = mimeType;\n            });\n\n        // Push each bufferView to the GPU as a separate buffer\n        bufferViews.forEach(\n            (\n                {\n                    buffer: bufferIndex, // required\n                    byteOffset = 0, // optional\n                    byteLength, // required\n                    byteStride, // optional\n                    target = gl.ARRAY_BUFFER, // optional, added above for elements\n                    name, // optional\n                    extensions, // optional\n                    extras, // optional\n\n                    componentType, // optional, added from accessor above\n                    mimeType, // optional, added from images above\n                    isAttribute,\n                    isDraco,\n                },\n                i\n            ) => {\n                bufferViews[i].data = buffers[bufferIndex].slice(byteOffset, byteOffset + byteLength);\n\n                if (!isAttribute || isDraco) return;\n                // Create gl buffers for the bufferView, pushing it to the GPU\n                const buffer = gl.createBuffer();\n                gl.bindBuffer(target, buffer);\n                gl.renderer.state.boundBuffer = buffer;\n                gl.bufferData(target, bufferViews[i].data, gl.STATIC_DRAW);\n                bufferViews[i].buffer = buffer;\n            }\n        );\n\n        return bufferViews;\n    }\n\n    static parseImages(gl, desc, dir, bufferViews) {\n        if (!desc.images) return null;\n        return Promise.all(\n            desc.images.map(async ({ uri, bufferView: bufferViewIndex, mimeType, name }) => {\n                if (mimeType === 'image/ktx2') {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const image = await this.basisManager.parseTexture(data);\n                    return image;\n                }\n\n                // jpg / png / webp\n                const image = new Image();\n                image.name = name;\n                if (uri) {\n                    image.src = this.resolveURI(uri, dir);\n                } else if (bufferViewIndex !== undefined) {\n                    const { data } = bufferViews[bufferViewIndex];\n                    const blob = new Blob([data], { type: mimeType });\n                    image.src = URL.createObjectURL(blob);\n                }\n                image.ready = new Promise((res) => {\n                    image.onload = () => res();\n                });\n                return image;\n            })\n        );\n    }\n\n    static parseTextures(gl, desc, images) {\n        if (!desc.textures) return null;\n        return desc.textures.map((textureInfo) => this.createTexture(gl, desc, images, textureInfo));\n    }\n\n    static createTexture(gl, desc, images, { sampler: samplerIndex, source: sourceIndex, name, extensions, extras }) {\n        if (sourceIndex === undefined && !!extensions) {\n            // WebP extension source index\n            if (extensions.EXT_texture_webp) sourceIndex = extensions.EXT_texture_webp.source;\n\n            // Basis extension source index\n            if (extensions.KHR_texture_basisu) sourceIndex = extensions.KHR_texture_basisu.source;\n        }\n\n        const image = images[sourceIndex];\n        if (image.texture) return image.texture;\n\n        const options = {\n            flipY: false,\n            wrapS: gl.REPEAT, // Repeat by default, opposed to OGL's clamp by default\n            wrapT: gl.REPEAT,\n        };\n        const sampler = samplerIndex !== undefined ? desc.samplers[samplerIndex] : null;\n        if (sampler) {\n            ['magFilter', 'minFilter', 'wrapS', 'wrapT'].forEach((prop) => {\n                if (sampler[prop]) options[prop] = sampler[prop];\n            });\n        }\n\n        // For compressed textures\n        if (image.isBasis) {\n            options.image = image;\n            options.internalFormat = image.internalFormat;\n            if (image.isCompressedTexture) {\n                options.generateMipmaps = false;\n                if (image.length > 1) this.minFilter = gl.NEAREST_MIPMAP_LINEAR;\n            }\n            const texture = new Texture(gl, options);\n            texture.name = name;\n            image.texture = texture;\n            return texture;\n        }\n\n        const texture = new Texture(gl, options);\n        texture.name = name;\n        image.texture = texture;\n        image.ready.then(() => {\n            texture.image = image;\n        });\n\n        return texture;\n    }\n\n    static parseMaterials(gl, desc, textures) {\n        if (!desc.materials) return null;\n        return desc.materials.map(\n            ({\n                name,\n                extensions,\n                extras,\n                pbrMetallicRoughness = {},\n                normalTexture,\n                occlusionTexture,\n                emissiveTexture,\n                emissiveFactor = [0, 0, 0],\n                alphaMode = 'OPAQUE',\n                alphaCutoff = 0.5,\n                doubleSided = false,\n            }) => {\n                const {\n                    baseColorFactor = [1, 1, 1, 1],\n                    baseColorTexture,\n                    metallicFactor = 1,\n                    roughnessFactor = 1,\n                    metallicRoughnessTexture,\n                    //   extensions,\n                    //   extras,\n                } = pbrMetallicRoughness;\n\n                if (baseColorTexture) {\n                    baseColorTexture.texture = textures[baseColorTexture.index];\n                    // texCoord\n                }\n                if (normalTexture) {\n                    normalTexture.texture = textures[normalTexture.index];\n                    // scale: 1\n                    // texCoord\n                }\n                if (metallicRoughnessTexture) {\n                    metallicRoughnessTexture.texture = textures[metallicRoughnessTexture.index];\n                    // texCoord\n                }\n                if (occlusionTexture) {\n                    occlusionTexture.texture = textures[occlusionTexture.index];\n                    // strength 1\n                    // texCoord\n                }\n                if (emissiveTexture) {\n                    emissiveTexture.texture = textures[emissiveTexture.index];\n                    // texCoord\n                }\n\n                return {\n                    name,\n                    extensions,\n                    extras,\n                    baseColorFactor,\n                    baseColorTexture,\n                    metallicFactor,\n                    roughnessFactor,\n                    metallicRoughnessTexture,\n                    normalTexture,\n                    occlusionTexture,\n                    emissiveTexture,\n                    emissiveFactor,\n                    alphaMode,\n                    alphaCutoff,\n                    doubleSided,\n                };\n            }\n        );\n    }\n\n    static parseSkins(gl, desc, bufferViews) {\n        if (!desc.skins) return null;\n        return desc.skins.map(\n            ({\n                inverseBindMatrices, // optional\n                skeleton, // optional\n                joints, // required\n                // name,\n                // extensions,\n                // extras,\n            }) => {\n                return {\n                    inverseBindMatrices: this.parseAccessor(inverseBindMatrices, desc, bufferViews),\n                    skeleton,\n                    joints,\n                };\n            }\n        );\n    }\n\n    static parseMeshes(gl, desc, bufferViews, materials, skins) {\n        if (!desc.meshes) return null;\n        return Promise.all(\n            desc.meshes.map(\n                async (\n                    {\n                        primitives, // required\n                        weights, // optional\n                        name, // optional\n                        extensions, // optional\n                        extras = {}, // optional - will get merged with node extras\n                    },\n                    meshIndex\n                ) => {\n                    // TODO: weights stuff?\n                    // Parse through nodes to see how many instances there are and if there is a skin attached\n                    // If multiple instances of a skin, need to create each\n                    let numInstances = 0;\n                    let skinIndices = [];\n                    let isLightmap = false;\n                    desc.nodes &&\n                        desc.nodes.forEach(({ mesh, skin, extras }) => {\n                            if (mesh === meshIndex) {\n                                numInstances++;\n                                if (skin !== undefined) skinIndices.push(skin);\n                                if (extras && extras.lightmap_scale_offset) isLightmap = true;\n                            }\n                        });\n                    let isSkin = !!skinIndices.length;\n\n                    // For skins, return array of skin meshes to account for multiple instances\n                    if (isSkin) {\n                        primitives = await Promise.all(\n                            skinIndices.map(async (skinIndex) => {\n                                return (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, 1, isLightmap)).map(({ geometry, program, mode }) => {\n                                    const mesh = new GLTFSkin(gl, { skeleton: skins[skinIndex], geometry, program, mode });\n                                    mesh.name = name;\n                                    mesh.extras = extras;\n                                    if (extensions) mesh.extensions = extensions;\n                                    // TODO: support skin frustum culling\n                                    mesh.frustumCulled = false;\n                                    return mesh;\n                                });\n                            })\n                        );\n                        // For retrieval to add to node\n                        primitives.instanceCount = 0;\n                        primitives.numInstances = numInstances;\n                    } else {\n                        primitives = (await this.parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap)).map(({ geometry, program, mode }) => {\n                            // InstancedMesh class has custom frustum culling for instances\n                            const meshConstructor = geometry.attributes.instanceMatrix ? InstancedMesh : Mesh;\n                            const mesh = new meshConstructor(gl, { geometry, program, mode });\n                            mesh.name = name;\n                            mesh.extras = extras;\n                            if (extensions) mesh.extensions = extensions;\n                            // Tag mesh so that nodes can add their transforms to the instance attribute\n                            mesh.numInstances = numInstances;\n                            return mesh;\n                        });\n                    }\n\n                    return {\n                        primitives,\n                        weights,\n                        name,\n                    };\n                }\n            )\n        );\n    }\n\n    static parsePrimitives(gl, primitives, desc, bufferViews, materials, numInstances, isLightmap) {\n        return Promise.all(\n            primitives.map(\n                async ({\n                    attributes, // required\n                    indices, // optional\n                    material: materialIndex, // optional\n                    mode = 4, // optional\n                    targets, // optional\n                    extensions, // optional\n                    extras, // optional\n                }) => {\n                    // TODO: materials\n                    const program = new NormalProgram(gl);\n                    if (materialIndex !== undefined) {\n                        program.gltfMaterial = materials[materialIndex];\n                    }\n\n                    const geometry = new Geometry(gl);\n                    if (extras) geometry.extras = extras;\n                    if (extensions) geometry.extensions = extensions;\n\n                    // For compressed geometry data\n                    if (extensions && extensions.KHR_draco_mesh_compression) {\n                        const bufferViewIndex = extensions.KHR_draco_mesh_compression.bufferView;\n                        const gltfAttributeMap = extensions.KHR_draco_mesh_compression.attributes;\n                        const attributeMap = {};\n                        const attributeTypeMap = {};\n                        const attributeTypeNameMap = {};\n                        const attributeNormalizedMap = {};\n\n                        for (const attr in attributes) {\n                            const accessor = desc.accessors[attributes[attr]];\n                            const attributeName = ATTRIBUTES[attr];\n                            attributeMap[attributeName] = gltfAttributeMap[attr];\n                            attributeTypeMap[attributeName] = accessor.componentType;\n                            attributeTypeNameMap[attributeName] = TYPE_ARRAY[accessor.componentType].name;\n                            attributeNormalizedMap[attributeName] = accessor.normalized === true;\n                        }\n\n                        const { data } = bufferViews[bufferViewIndex];\n                        const geometryData = await this.dracoManager.decodeGeometry(data, {\n                            attributeIds: attributeMap,\n                            attributeTypes: attributeTypeNameMap,\n                        });\n\n                        // Add each attribute result\n                        for (let i = 0; i < geometryData.attributes.length; i++) {\n                            const result = geometryData.attributes[i];\n                            const name = result.name;\n                            const data = result.array;\n                            const size = result.itemSize;\n                            const type = attributeTypeMap[name];\n                            const normalized = attributeNormalizedMap[name];\n\n                            // Create gl buffers for the attribute data, pushing it to the GPU\n                            const buffer = gl.createBuffer();\n                            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                            gl.renderer.state.boundBuffer = buffer;\n                            gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n                            geometry.addAttribute(name, {\n                                data,\n                                size,\n                                type,\n                                normalized,\n                                buffer,\n                            });\n                        }\n\n                        // Add index attribute if found\n                        if (geometryData.index) {\n                            const data = geometryData.index.array;\n                            const size = geometryData.index.itemSize;\n\n                            // Create gl buffers for the index attribute data, pushing it to the GPU\n                            const buffer = gl.createBuffer();\n                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n                            gl.renderer.state.boundBuffer = buffer;\n                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n                            geometry.addAttribute('index', {\n                                data,\n                                size,\n                                type: 5125, // Uint32Array\n                                normalized: false,\n                                buffer,\n                            });\n                        }\n                    } else {\n                        // Add each attribute found in primitive\n                        for (const attr in attributes) {\n                            geometry.addAttribute(ATTRIBUTES[attr], this.parseAccessor(attributes[attr], desc, bufferViews));\n                        }\n\n                        // Add index attribute if found\n                        if (indices !== undefined) {\n                            geometry.addAttribute('index', this.parseAccessor(indices, desc, bufferViews));\n                        }\n                    }\n\n                    // Add instanced transform attribute if multiple instances\n                    // Ignore if skin as we don't support instanced skins out of the box\n                    if (numInstances > 1) {\n                        geometry.addAttribute('instanceMatrix', {\n                            instanced: 1,\n                            size: 16,\n                            data: new Float32Array(numInstances * 16),\n                        });\n                    }\n\n                    // Always supply lightmapScaleOffset as an instanced attribute\n                    // Instanced skin lightmaps not supported\n                    if (isLightmap) {\n                        geometry.addAttribute('lightmapScaleOffset', {\n                            instanced: 1,\n                            size: 4,\n                            data: new Float32Array(numInstances * 4),\n                        });\n                    }\n\n                    return {\n                        geometry,\n                        program,\n                        mode,\n                    };\n                }\n            )\n        );\n    }\n\n    static parseAccessor(index, desc, bufferViews) {\n        // TODO: init missing bufferView with 0s\n        // TODO: support sparse\n\n        const {\n            bufferView: bufferViewIndex, // optional\n            byteOffset = 0, // optional\n            componentType, // required\n            normalized = false, // optional\n            count, // required\n            type, // required\n            min, // optional\n            max, // optional\n            sparse, // optional\n            // name, // optional\n            // extensions, // optional\n            // extras, // optional\n        } = desc.accessors[index];\n\n        const {\n            data, // attached in parseBufferViews\n            buffer, // replaced to be the actual GL buffer\n            byteOffset: bufferByteOffset = 0,\n            // byteLength, // applied in parseBufferViews\n            byteStride = 0,\n            target,\n            // name,\n            // extensions,\n            // extras,\n        } = bufferViews[bufferViewIndex];\n\n        const size = TYPE_SIZE[type];\n\n        // Parse data from joined buffers\n        const TypeArray = TYPE_ARRAY[componentType];\n        const elementBytes = TypeArray.BYTES_PER_ELEMENT;\n        const componentStride = byteStride / elementBytes;\n        const isInterleaved = !!byteStride && componentStride !== size;\n\n        let filteredData;\n\n        // Convert data to typed array for various uses (bounding boxes, raycasting, animation, merging etc)\n        if (isInterleaved) {\n            // First convert entire buffer to type\n            const typedData = new TypeArray(data, byteOffset);\n            // TODO: add length to not copy entire buffer if can help it\n            // const typedData = new TypeArray(data, byteOffset, (count - 1) * componentStride)\n\n            // Create output with length\n            filteredData = new TypeArray(count * size);\n\n            // Add element by element\n            for (let i = 0; i < count; i++) {\n                const start = componentStride * i;\n                const end = start + size;\n                filteredData.set(typedData.slice(start, end), i * size);\n            }\n        } else {\n            // Simply a slice\n            filteredData = new TypeArray(data, byteOffset, count * size);\n        }\n\n        // Return attribute data\n        return {\n            data: filteredData,\n            size,\n            type: componentType,\n            normalized,\n            buffer,\n            stride: byteStride,\n            offset: byteOffset,\n            count,\n            min,\n            max,\n        };\n    }\n\n    static parseNodes(gl, desc, meshes, skins, images) {\n        if (!desc.nodes) return null;\n        const cameras = [];\n        const nodes = desc.nodes.map(\n            ({\n                camera, // optional\n                children, // optional\n                skin: skinIndex, // optional\n                matrix, // optional\n                mesh: meshIndex, // optional\n                rotation, // optional\n                scale, // optional\n                translation, // optional\n                weights, // optional\n                name, // optional\n                extensions, // optional\n                extras, // optional\n            }) => {\n                const isCamera = camera !== undefined;\n\n                const node = isCamera ? new Camera(gl) : new Transform();\n\n                if (isCamera) {\n                    // NOTE: chose to use node's name and extras/extensions over camera\n                    const cameraOpts = desc.cameras[camera];\n                    if (cameraOpts.type === 'perspective') {\n                        const { yfov: fov, znear: near, zfar: far } = cameraOpts.perspective;\n                        node.perspective({ fov: fov * (180 / Math.PI), near, far });\n                    } else {\n                        const { xmag, ymag, znear: near, zfar: far } = cameraOpts.orthographic;\n                        node.orthographic({ near, far, left: -xmag, right: xmag, top: -ymag, bottom: ymag });\n                    }\n                    cameras.push(node);\n                }\n\n                if (name) node.name = name;\n                if (extras) node.extras = extras;\n                if (extensions) node.extensions = extensions;\n\n                // Need to attach to node as may have same material but different lightmap\n                if (extras && extras.lightmapTexture !== undefined) {\n                    extras.lightmapTexture.texture = this.createTexture(gl, desc, images, { source: extras.lightmapTexture.index });\n                }\n\n                // Apply transformations\n                if (matrix) {\n                    node.matrix.copy(matrix);\n                    node.decompose();\n                } else {\n                    if (rotation) node.quaternion.copy(rotation);\n                    if (scale) node.scale.copy(scale);\n                    if (translation) node.position.copy(translation);\n                    node.updateMatrix();\n                }\n\n                // Flags for avoiding duplicate transforms and removing unused instance nodes\n                let isInstanced = false;\n                let isFirstInstance = true;\n                let isInstancedMatrix = false;\n                let isSkin = skinIndex !== undefined;\n\n                // Add mesh if included\n                if (meshIndex !== undefined) {\n                    if (isSkin) {\n                        meshes[meshIndex].primitives[meshes[meshIndex].primitives.instanceCount].forEach((mesh) => {\n                            if (extras) Object.assign(mesh.extras, extras);\n                            mesh.setParent(node);\n                        });\n                        meshes[meshIndex].primitives.instanceCount++;\n                        // Remove properties once all instances added\n                        if (meshes[meshIndex].primitives.instanceCount === meshes[meshIndex].primitives.numInstances) {\n                            delete meshes[meshIndex].primitives.numInstances;\n                            delete meshes[meshIndex].primitives.instanceCount;\n                        }\n                    } else {\n                        meshes[meshIndex].primitives.forEach((mesh) => {\n                            if (extras) Object.assign(mesh.extras, extras);\n\n                            // Instanced mesh might only have 1\n                            if (mesh.geometry.isInstanced) {\n                                isInstanced = true;\n                                if (!mesh.instanceCount) {\n                                    mesh.instanceCount = 0;\n                                } else {\n                                    isFirstInstance = false;\n                                }\n                                if (mesh.geometry.attributes.instanceMatrix) {\n                                    isInstancedMatrix = true;\n                                    node.matrix.toArray(mesh.geometry.attributes.instanceMatrix.data, mesh.instanceCount * 16);\n                                }\n\n                                if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                    mesh.geometry.attributes.lightmapScaleOffset.data.set(extras.lightmap_scale_offset, mesh.instanceCount * 4);\n                                }\n\n                                mesh.instanceCount++;\n\n                                if (mesh.instanceCount === mesh.numInstances) {\n                                    // Remove properties once all instances added\n                                    delete mesh.numInstances;\n                                    delete mesh.instanceCount;\n                                    // Flag attribute as dirty\n                                    if (mesh.geometry.attributes.instanceMatrix) {\n                                        mesh.geometry.attributes.instanceMatrix.needsUpdate = true;\n                                    }\n                                    if (mesh.geometry.attributes.lightmapScaleOffset) {\n                                        mesh.geometry.attributes.lightmapScaleOffset.needsUpdate = true;\n                                    }\n                                }\n                            }\n\n                            // For instances, only the first node will actually have the mesh\n                            if (isInstanced) {\n                                if (isFirstInstance) mesh.setParent(node);\n                            } else {\n                                mesh.setParent(node);\n                            }\n                        });\n                    }\n                }\n\n                // Reset node if instanced to not duplicate transforms\n                if (isInstancedMatrix) {\n                    // Remove unused nodes just providing an instance transform\n                    if (!isFirstInstance) return null;\n                    // Avoid duplicate transform for node containing the instanced mesh\n                    node.matrix.identity();\n                    node.decompose();\n                }\n\n                return node;\n            }\n        );\n\n        desc.nodes.forEach(({ children = [] }, i) => {\n            // Set hierarchy now all nodes created\n            children.forEach((childIndex) => {\n                if (!nodes[childIndex]) return;\n                nodes[childIndex].setParent(nodes[i]);\n            });\n        });\n\n        // Add frustum culling for instances now that instanceMatrix attribute is populated\n        meshes.forEach(({ primitives }, i) => {\n            primitives.forEach((primitive, i) => {\n                if (primitive.isInstancedMesh) primitive.addFrustumCull();\n            });\n        });\n\n        return [nodes, cameras];\n    }\n\n    static populateSkins(skins, nodes) {\n        if (!skins) return;\n        skins.forEach((skin) => {\n            skin.joints = skin.joints.map((i, index) => {\n                const joint = nodes[i];\n                joint.skin = skin;\n                joint.bindInverse = new Mat4(...skin.inverseBindMatrices.data.slice(index * 16, (index + 1) * 16));\n                return joint;\n            });\n            if (skin.skeleton) skin.skeleton = nodes[skin.skeleton];\n        });\n    }\n\n    static parseAnimations(gl, desc, nodes, bufferViews) {\n        if (!desc.animations) return null;\n        return desc.animations.map(\n            (\n                {\n                    channels, // required\n                    samplers, // required\n                    name, // optional\n                    // extensions, // optional\n                    // extras,  // optional\n                },\n                animationIndex\n            ) => {\n                const data = channels.map(\n                    ({\n                        sampler: samplerIndex, // required\n                        target, // required\n                        // extensions, // optional\n                        // extras, // optional\n                    }) => {\n                        const {\n                            input: inputIndex, // required\n                            interpolation = 'LINEAR',\n                            output: outputIndex, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = samplers[samplerIndex];\n\n                        const {\n                            node: nodeIndex, // optional - TODO: when is it not included?\n                            path, // required\n                            // extensions, // optional\n                            // extras, // optional\n                        } = target;\n\n                        const node = nodes[nodeIndex];\n                        const transform = TRANSFORMS[path];\n                        const times = this.parseAccessor(inputIndex, desc, bufferViews).data;\n                        const values = this.parseAccessor(outputIndex, desc, bufferViews).data;\n\n                        // Store reference on node for cyclical retrieval\n                        if (!node.animations) node.animations = [];\n                        if (!node.animations.includes(animationIndex)) node.animations.push(animationIndex);\n\n                        return {\n                            node,\n                            transform,\n                            interpolation,\n                            times,\n                            values,\n                        };\n                    }\n                );\n\n                return {\n                    name,\n                    animation: new GLTFAnimation(data),\n                };\n            }\n        );\n    }\n\n    static parseScenes(desc, nodes) {\n        if (!desc.scenes) return null;\n        return desc.scenes.map(\n            ({\n                nodes: nodesIndices = [],\n                name, // optional\n                extensions,\n                extras,\n            }) => {\n                const scene = nodesIndices.reduce((map, i) => {\n                    // Don't add null nodes (instanced transforms)\n                    if (nodes[i]) map.push(nodes[i]);\n                    return map;\n                }, []);\n                scene.extras = extras;\n                return scene;\n            }\n        );\n    }\n\n    static parseLights(gl, desc, nodes, scenes) {\n        const lights = {\n            directional: [],\n            point: [],\n            spot: [],\n        };\n\n        // Update matrices on root nodes\n        scenes.forEach((scene) => scene.forEach((node) => node.updateMatrixWorld()));\n\n        // Uses KHR_lights_punctual extension\n        const lightsDescArray = desc.extensions?.KHR_lights_punctual?.lights || [];\n\n        // Need nodes for transforms\n        nodes.forEach((node) => {\n            if (!node?.extensions?.KHR_lights_punctual) return;\n            const lightIndex = node.extensions.KHR_lights_punctual.light;\n            const lightDesc = lightsDescArray[lightIndex];\n            const light = {\n                name: lightDesc.name || '',\n                color: { value: new Vec3().set(lightDesc.color || 1) },\n            };\n            // Apply intensity directly to color\n            if (lightDesc.intensity !== undefined) light.color.value.multiply(lightDesc.intensity);\n\n            switch (lightDesc.type) {\n                case 'directional':\n                    light.direction = { value: new Vec3(0, 0, 1).transformDirection(node.worldMatrix) };\n                    break;\n                case 'point':\n                    light.position = { value: new Vec3().applyMatrix4(node.worldMatrix) };\n                    light.distance = { value: lightDesc.range };\n                    light.decay = { value: 2 };\n                    break;\n                case 'spot':\n                    // TODO: support spot uniforms\n                    Object.assign(light, lightDesc);\n                    break;\n            }\n\n            lights[lightDesc.type].push(light);\n        });\n\n        return lights;\n    }\n}\n","let id = 0;\n\nexport class DracoManager {\n    constructor(workerSrc) {\n        this.onMessage = this.onMessage.bind(this);\n        this.queue = new Map();\n        this.initWorker(workerSrc);\n    }\n\n    initWorker(workerSrc) {\n        this.worker = new Worker(workerSrc);\n        this.worker.onmessage = this.onMessage;\n    }\n\n    onMessage({ data }) {\n        const { id, error, geometry } = data;\n        if (error) {\n            console.log(error, id);\n            return;\n        }\n        const geometryResolve = this.queue.get(id);\n        this.queue.delete(id);\n        geometryResolve(geometry);\n    }\n\n    decodeGeometry(buffer, config) {\n        id++;\n        this.worker.postMessage({\n            id,\n            buffer,\n            config,\n        });\n        let geometryResolve;\n        const promise = new Promise((res) => (geometryResolve = res));\n        this.queue.set(id, geometryResolve);\n        return promise;\n    }\n}\n","let supportedFormat;\nlet id = 0;\n\nexport class BasisManager {\n    constructor(workerSrc, gl) {\n        if (!supportedFormat) supportedFormat = this.getSupportedFormat(gl);\n        this.onMessage = this.onMessage.bind(this);\n        this.queue = new Map();\n        this.initWorker(workerSrc);\n    }\n\n    getSupportedFormat(gl = document.createElement('canvas').getContext('webgl')) {\n        /* if (!!gl.getExtension('WEBGL_compressed_texture_etc')) {\n            return 'etc2';\n        } else  */\n        if (!!gl.getExtension('WEBGL_compressed_texture_astc')) {\n            return 'astc';\n        } else if (!!gl.getExtension('EXT_texture_compression_bptc')) {\n            return 'bptc';\n        } else if (!!gl.getExtension('WEBGL_compressed_texture_s3tc')) {\n            return 's3tc';\n        } else if (!!gl.getExtension('WEBGL_compressed_texture_etc1')) {\n            return 'etc1';\n        } else if (!!gl.getExtension('WEBGL_compressed_texture_pvrtc') || !!gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')) {\n            return 'pvrtc';\n            // } else if (!!gl.getExtension('WEBGL_compressed_texture_atc')) {\n            //     return 'atc';\n        }\n        return 'none';\n    }\n\n    initWorker(workerSrc) {\n        this.worker = new Worker(workerSrc);\n        this.worker.onmessage = this.onMessage;\n    }\n\n    onMessage({ data }) {\n        const { id, error, image } = data;\n        if (error) {\n            console.log(error, id);\n            return;\n        }\n        const textureResolve = this.queue.get(id);\n        this.queue.delete(id);\n        image.isBasis = true;\n        textureResolve(image);\n    }\n\n    parseTexture(buffer) {\n        id++;\n        this.worker.postMessage({\n            id,\n            buffer,\n            supportedFormat,\n        });\n        let textureResolve;\n        const promise = new Promise((res) => (textureResolve = res));\n        this.queue.set(id, textureResolve);\n        return promise;\n    }\n}\n","import { Mesh } from '../core/Mesh.js';\nimport { Program } from '../core/Program.js';\nimport { Geometry } from '../core/Geometry.js';\nimport { Color } from '../math/Color.js';\n\nexport class WireMesh extends Mesh {\n    constructor(gl, { geometry, wireColor = new Color(0, 0.75, 0.5), ...meshProps } = {}) {\n        const wireProgram = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: { wireColor: { value: wireColor } },\n        });\n\n        const positionArray = geometry.attributes.position.data;\n        const indices = [];\n        const hashSet = new Set();\n\n        function addUniqueIndices(idx) {\n            for (let i = 0; i < idx.length; i += 2) {\n                if (isUniqueEdgePosition(idx[i] * 3, idx[i + 1] * 3, positionArray, hashSet)) {\n                    indices.push(idx[i], idx[i + 1]);\n                }\n            }\n        }\n\n        if (geometry.attributes.index) {\n            const idata = geometry.attributes.index.data;\n\n            for (let i = 0; i < idata.length; i += 3) {\n                // For every triangle, make three line pairs (start, end)\n                // prettier-ignore\n                addUniqueIndices([\n                    idata[i], idata[i + 1],\n                    idata[i + 1], idata[i + 2],\n                    idata[i + 2], idata[i]\n                ]);\n            }\n        } else {\n            const numVertices = Math.floor(positionArray.length / 3);\n\n            for (let i = 0; i < numVertices; i += 3) {\n                addUniqueIndices([i, i + 1, i + 1, i + 2, i + 2, i]);\n            }\n        }\n\n        const indicesTyped = indices.length > 65536 ? new Uint32Array(indices) : new Uint16Array(indices);\n        const wireGeometry = new Geometry(gl, {\n            position: { ...geometry.attributes.position },\n            index: { data: indicesTyped },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry: wireGeometry, program: wireProgram });\n    }\n}\n\n// from https://github.com/mrdoob/three.js/blob/0c26bb4bb8220126447c8373154ac045588441de/src/geometries/WireframeGeometry.js#L116\nfunction isUniqueEdgePosition(start, end, pos, hashSet) {\n    // prettier-ignore\n    const hash1 = [\n        pos[start], pos[start + 1], pos[start + 2],\n        pos[end], pos[end + 1], pos[end + 2]\n    ].join('#');\n\n    // coincident edge\n    // prettier-ignore\n    const hash2 = [\n        pos[end], pos[end + 1], pos[end + 2],\n        pos[start], pos[start + 1], pos[start + 2]\n    ].join('#');\n\n    const oldSize = hashSet.size;\n    hashSet.add(hash1);\n    hashSet.add(hash2);\n    return hashSet.size - oldSize === 2;\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 wireColor;\n\nvoid main() {    \n    gl_FragColor = vec4(wireColor, 1.0);\n}\n`;\n","import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\n\nexport class AxesHelper extends Mesh {\n    constructor(\n        gl,\n        {\n            size = 1,\n            symmetric = false,\n            xColor = new Vec3(0.96, 0.21, 0.32),\n            yColor = new Vec3(0.44, 0.64, 0.11),\n            zColor = new Vec3(0.18, 0.52, 0.89),\n            ...meshProps\n        } = {}\n    ) {\n        const a = symmetric ? -size : 0;\n        const b = size;\n\n        // prettier-ignore\n        const vertices = new Float32Array([\n\t\t\ta, 0, 0,  b, 0, 0,\n\t\t\t0, a, 0,  0, b, 0,\n\t\t\t0, 0, a,  0, 0, b\n\t\t]);\n\n        // prettier-ignore\n        const colors = new Float32Array([\n\t\t\t...xColor,  ...xColor,\n\t\t\t...yColor,  ...yColor,\n\t\t\t...zColor,  ...zColor\n\t\t]);\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: vertices },\n            color: { size: 3, data: colors },\n        });\n\n        const program = new Program(gl, { vertex, fragment });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 color;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvarying vec3 vColor;\n\nvoid main() {    \n    vColor = color;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nvarying vec3 vColor;\n\nvoid main() {    \n    gl_FragColor = vec4(vColor, 1.0);\n}\n`;\n","import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\n\nexport class GridHelper extends Mesh {\n    constructor(gl, { size = 10, divisions = 10, color = new Vec3(0.75, 0.75, 0.75), ...meshProps } = {}) {\n        const numVertices = (size + 1) * 2 * 2;\n        const vertices = new Float32Array(numVertices * 3);\n\n        const hs = size / 2;\n        for (let i = 0; i <= divisions; i++) {\n            const t = i / divisions;\n            const o = t * size - hs;\n\n            vertices.set([o, 0, -hs, o, 0, hs], i * 12);\n            vertices.set([-hs, 0, o, hs, 0, o], i * 12 + 6);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: vertices },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n            },\n        });\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n","import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { Mat3 } from '../../math/Mat3.js';\n\nexport class VertexNormalsHelper extends Mesh {\n    constructor(object, { size = 0.1, color = new Vec3(0.86, 0.16, 0.86), ...meshProps } = {}) {\n        const gl = object.gl;\n        const nNormals = object.geometry.attributes.normal.count;\n        const positionsArray = new Float32Array(nNormals * 2 * 3);\n        const normalsArray = new Float32Array(nNormals * 2 * 3);\n        const sizeArray = new Float32Array(nNormals * 2);\n\n        const normalData = object.geometry.attributes.normal.data;\n        const positionData = object.geometry.attributes.position.data;\n        const sizeData = new Float32Array([0, size]);\n\n        for (let i = 0; i < nNormals; i++) {\n            const i6 = i * 6;\n            const i3 = i * 3;\n\n            // duplicate position and normal for line start and end point\n            const pSub = positionData.subarray(i3, i3 + 3);\n            positionsArray.set(pSub, i6);\n            positionsArray.set(pSub, i6 + 3);\n\n            const nSub = normalData.subarray(i3, i3 + 3);\n            normalsArray.set(nSub, i6);\n            normalsArray.set(nSub, i6 + 3);\n\n            sizeArray.set(sizeData, i * 2);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: positionsArray },\n            normal: { size: 3, data: normalsArray },\n            size: { size: 1, data: sizeArray },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n                worldNormalMatrix: { value: new Mat3() },\n                objectWorldMatrix: { value: object.worldMatrix },\n            },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n\n        this.object = object;\n    }\n\n    draw(arg) {\n        this.program.uniforms.worldNormalMatrix.value.getNormalMatrix(this.object.worldMatrix);\n        super.draw(arg);\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 normal;\nattribute float size;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 objectWorldMatrix;\nuniform mat3 worldNormalMatrix;\n\nvoid main() {\n    vec3 n = normalize(worldNormalMatrix * normal) * size;\n    vec3 p = (objectWorldMatrix * vec4(position, 1.0)).xyz;\n    gl_Position = projectionMatrix * viewMatrix * vec4(p + n, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n","import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { Mat3 } from '../../math/Mat3.js';\n\nconst vA = /* @__PURE__ */ new Vec3();\nconst vB = /* @__PURE__ */ new Vec3();\nconst vC = /* @__PURE__ */ new Vec3();\nconst vCenter = /* @__PURE__ */ new Vec3();\nconst vNormal = /* @__PURE__ */ new Vec3();\n\nexport class FaceNormalsHelper extends Mesh {\n    constructor(object, { size = 0.1, color = new Vec3(0.15, 0.86, 0.86), ...meshProps } = {}) {\n        const gl = object.gl;\n\n        const positionData = object.geometry.attributes.position.data;\n        const sizeData = new Float32Array([0, size]);\n\n        const indexAttr = object.geometry.attributes.index;\n        const getIndex = indexAttr ? (i) => indexAttr.data[i] : (i) => i;\n        const numVertices = indexAttr ? indexAttr.data.length : Math.floor(positionData.length / 3);\n\n        const nNormals = Math.floor(numVertices / 3);\n        const positionsArray = new Float32Array(nNormals * 2 * 3);\n        const normalsArray = new Float32Array(nNormals * 2 * 3);\n        const sizeArray = new Float32Array(nNormals * 2);\n\n        for (let i = 0; i < numVertices; i += 3) {\n            vA.fromArray(positionData, getIndex(i + 0) * 3);\n            vB.fromArray(positionData, getIndex(i + 1) * 3);\n            vC.fromArray(positionData, getIndex(i + 2) * 3);\n\n            vCenter\n                .add(vA, vB)\n                .add(vC)\n                .multiply(1 / 3);\n\n            vA.sub(vA, vB);\n            vC.sub(vC, vB);\n            vNormal.cross(vC, vA).normalize();\n\n            // duplicate position and normal for line start and end point\n            const i2 = i * 2;\n            positionsArray.set(vCenter, i2);\n            positionsArray.set(vCenter, i2 + 3);\n\n            normalsArray.set(vNormal, i2);\n            normalsArray.set(vNormal, i2 + 3);\n            sizeArray.set(sizeData, (i / 3) * 2);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: positionsArray },\n            normal: { size: 3, data: normalsArray },\n            size: { size: 1, data: sizeArray },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n                worldNormalMatrix: { value: new Mat3() },\n                objectWorldMatrix: { value: object.worldMatrix },\n            },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n\n        this.object = object;\n    }\n\n    draw(arg) {\n        this.program.uniforms.worldNormalMatrix.value.getNormalMatrix(this.object.worldMatrix);\n        super.draw(arg);\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 normal;\nattribute float size;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 objectWorldMatrix;\nuniform mat3 worldNormalMatrix;\n\nvoid main() {\n    vec3 n = normalize(worldNormalMatrix * normal) * size;\n    vec3 p = (objectWorldMatrix * vec4(position, 1.0)).xyz;\n    gl_Position = projectionMatrix * viewMatrix * vec4(p + n, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n","import { Texture } from '../core/Texture.js';\n\nexport class Texture3D extends Texture {\n    constructor(gl, args) {\n        super(gl, {\n            ...args,\n            target: gl.TEXTURE_3D,\n            width: args.width ? args.width : 2,\n            height: args.height ? args.height : 2,\n        });\n\n        const image = new Image();\n        image.crossOrigin = '*';\n        image.src = args.src;\n\n        image.onload = () => {\n            let canvas = document.createElement('canvas');\n            canvas.width = image.width;\n            canvas.height = image.height;\n\n            let ctx = canvas.getContext('2d');\n            ctx.scale(1, -1);\n            ctx.translate(0, -image.height);\n            ctx.drawImage(image, 0, 0);\n            const imageData = ctx.getImageData(0, 0, image.width, image.height).data;\n\n            canvas = null;\n            ctx = null;\n            let elementCount;\n\n            switch (this.format) {\n                case gl.RED:\n                    elementCount = 1;\n                    break;\n                case gl.RG:\n                    elementCount = 2;\n                    break;\n                case gl.RGB:\n                    elementCount = 3;\n                    break;\n                default:\n                    elementCount = 4;\n                    break;\n            }\n\n            const dataCount = this.width * this.height * this.length * elementCount;\n            const data = this.type === gl.UNSIGNED_BYTE ? new Uint8Array(dataCount) : new Float32Array(dataCount);\n\n            let dataIterator = 0;\n\n            for (let z = 0; z < this.length; z++) {\n                for (let y = 0; y < this.height; y++) {\n                    for (let x = 0; x < this.width; x++) {\n                        let zOffsetX = (z % args.tileCountX) * this.width;\n                        let zOffsetY = Math.floor(z / args.tileCountX) * (this.width * this.height * args.tileCountX);\n                        let index = x + zOffsetX + (y * image.width + zOffsetY);\n\n                        const r = imageData[index * 4];\n                        const g = imageData[index * 4 + 1];\n                        const b = imageData[index * 4 + 2];\n                        const a = imageData[index * 4 + 3];\n\n                        let texel = [r, g, b, a];\n\n                        for (let i = 0; i < elementCount; i++) {\n                            if (this.type === this.gl.UNSIGNED_BYTE) {\n                                data[dataIterator++] = texel[i];\n                            } else {\n                                data[dataIterator++] = texel[i] / 255;\n                            }\n                        }\n                    }\n                }\n            }\n\n            this.image = data;\n            this.needsUpdate = true;\n        };\n    }\n}\n"],"mappings":"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"}